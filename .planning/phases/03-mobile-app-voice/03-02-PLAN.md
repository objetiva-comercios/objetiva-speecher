---
phase: 03-mobile-app-voice
plan: 02
type: execute
wave: 1
depends_on: ["03-01"]
files_modified:
  - mobile-app/src/services/storage.ts
  - mobile-app/src/services/queue.ts
  - mobile-app/src/services/api.ts
autonomous: true

must_haves:
  truths:
    - "Queue persists transcriptions to device storage"
    - "API client can send transcriptions to backend"
    - "API client can fetch device list from backend"
    - "Queue survives app kill and restart"
  artifacts:
    - path: "mobile-app/src/services/storage.ts"
      provides: "Preferences abstraction"
      exports: ["getItem", "setItem", "removeItem"]
    - path: "mobile-app/src/services/queue.ts"
      provides: "Transcription queue with persistence"
      exports: ["loadQueue", "enqueue", "dequeue", "replayQueue"]
    - path: "mobile-app/src/services/api.ts"
      provides: "HTTP client for backend"
      exports: ["ApiClient"]
  key_links:
    - from: "mobile-app/src/services/queue.ts"
      to: "mobile-app/src/services/storage.ts"
      via: "import { getItem, setItem }"
      pattern: "import.*from.*storage"
    - from: "mobile-app/src/services/api.ts"
      to: "/transcription endpoint"
      via: "fetch POST"
      pattern: "transcription"
---

<objective>
Create the core services layer for storage, queue management, and API communication with the backend.

Purpose: Enable persistent offline queue and backend communication for transcription delivery.
Output: Storage, queue, and API services ready for use by hooks and components.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-mobile-app-voice/03-RESEARCH.md
@mobile-app/src/types/index.ts
@backend-server/src/routes/transcription.ts
@backend-server/src/routes/devices.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage service (Preferences abstraction)</name>
  <files>
    mobile-app/src/services/storage.ts
  </files>
  <action>
    Create src/services directory and storage.ts with Preferences abstraction.
    Per research: use @capacitor/preferences for reliable persistence on Android.

    ```typescript
    import { Preferences } from '@capacitor/preferences';

    /**
     * Get item from persistent storage.
     * Returns null if key doesn't exist.
     */
    export async function getItem(key: string): Promise<string | null> {
      const { value } = await Preferences.get({ key });
      return value;
    }

    /**
     * Set item in persistent storage.
     * Value must be a string (serialize JSON objects before storing).
     */
    export async function setItem(key: string, value: string): Promise<void> {
      await Preferences.set({ key, value });
    }

    /**
     * Remove item from persistent storage.
     */
    export async function removeItem(key: string): Promise<void> {
      await Preferences.remove({ key });
    }

    /**
     * Get JSON item from storage with type safety.
     * Returns null if key doesn't exist or parse fails.
     */
    export async function getJSON<T>(key: string): Promise<T | null> {
      const value = await getItem(key);
      if (!value) return null;
      try {
        return JSON.parse(value) as T;
      } catch {
        return null;
      }
    }

    /**
     * Set JSON item in storage.
     */
    export async function setJSON<T>(key: string, value: T): Promise<void> {
      await setItem(key, JSON.stringify(value));
    }

    // Storage keys used in the app
    export const STORAGE_KEYS = {
      QUEUE: 'transcription_queue',
      LAST_DEVICE: 'last_selected_device',
      BACKEND_URL: 'backend_url',
    } as const;
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/services/storage.ts | head -20`
    Exports correct functions: grep for "export async function"
  </verify>
  <done>
    Storage service created with Preferences abstraction.
    getItem, setItem, removeItem, getJSON, setJSON exported.
    Storage keys defined for queue, last device, backend URL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create queue service with persistence</name>
  <files>
    mobile-app/src/services/queue.ts
  </files>
  <action>
    Create queue.ts implementing offline queue with Preferences persistence.
    Per user decision: queue transcriptions when target device is offline.

    ```typescript
    import { v4 as uuidv4 } from 'uuid';
    import type { QueuedTranscription } from '../types';
    import { getJSON, setJSON, STORAGE_KEYS } from './storage';

    /**
     * Load queue from persistent storage.
     * Returns empty array if no queue exists.
     */
    export async function loadQueue(): Promise<QueuedTranscription[]> {
      const queue = await getJSON<QueuedTranscription[]>(STORAGE_KEYS.QUEUE);
      return queue ?? [];
    }

    /**
     * Save queue to persistent storage.
     * Called after every mutation for immediate persistence.
     */
    async function saveQueue(queue: QueuedTranscription[]): Promise<void> {
      await setJSON(STORAGE_KEYS.QUEUE, queue);
    }

    /**
     * Add transcription to queue.
     * Immediately persists to storage per research pitfall #4.
     * Returns the created queue item.
     */
    export async function enqueue(
      deviceId: string,
      text: string
    ): Promise<QueuedTranscription> {
      const queue = await loadQueue();
      const item: QueuedTranscription = {
        id: uuidv4(),
        deviceId,
        text,
        timestamp: Date.now(),
      };
      queue.push(item);
      await saveQueue(queue);
      return item;
    }

    /**
     * Remove transcription from queue by ID.
     * Used after successful delivery or swipe-to-delete.
     */
    export async function dequeue(id: string): Promise<void> {
      const queue = await loadQueue();
      const filtered = queue.filter(item => item.id !== id);
      await saveQueue(filtered);
    }

    /**
     * Get queue length without loading full queue.
     */
    export async function getQueueLength(): Promise<number> {
      const queue = await loadQueue();
      return queue.length;
    }

    /**
     * Replay queue: attempt to send each item, remove on success.
     * Stops on first failure to maintain order.
     * Returns number of successfully sent items.
     */
    export async function replayQueue(
      sendFn: (item: QueuedTranscription) => Promise<boolean>
    ): Promise<number> {
      const queue = await loadQueue();
      let sentCount = 0;

      for (const item of queue) {
        const success = await sendFn(item);
        if (success) {
          await dequeue(item.id);
          sentCount++;
        } else {
          // Stop on first failure, will retry later
          break;
        }
      }

      return sentCount;
    }

    /**
     * Clear entire queue.
     * Use with caution - typically only for testing/debugging.
     */
    export async function clearQueue(): Promise<void> {
      await saveQueue([]);
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/services/queue.ts | head -30`
    Imports storage: grep for "from './storage'"
    Exports functions: grep for "export async function"
  </verify>
  <done>
    Queue service created with persistence via storage service.
    enqueue persists immediately to survive app kill.
    replayQueue supports ordered delivery on reconnect.
    dequeue supports both successful delivery and swipe-to-delete.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API client service</name>
  <files>
    mobile-app/src/services/api.ts
  </files>
  <action>
    Create api.ts with HTTP client for backend communication.
    Uses native fetch per research (Capacitor handles HTTP on Android).
    Matches backend route contracts from Phase 1.

    ```typescript
    import type { ApiResponse, DevicesResponse, QueuedTranscription } from '../types';

    /**
     * API client for backend communication.
     * Requires baseUrl to be set before use.
     */
    export class ApiClient {
      private baseUrl: string;

      constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
      }

      /**
       * Update base URL (when backend discovered via mDNS or manual config).
       */
      setBaseUrl(url: string): void {
        this.baseUrl = url;
      }

      /**
       * Get current base URL.
       */
      getBaseUrl(): string {
        return this.baseUrl;
      }

      /**
       * Send transcription to backend for routing to device.
       * Returns success response or error response per backend contract.
       */
      async sendTranscription(deviceId: string, text: string): Promise<ApiResponse> {
        const response = await fetch(`${this.baseUrl}/transcription`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deviceId, text }),
        });

        return response.json() as Promise<ApiResponse>;
      }

      /**
       * Send queued transcription item.
       * Convenience wrapper that extracts deviceId and text from queue item.
       * Returns true if successful (success: true in response).
       */
      async sendQueuedItem(item: QueuedTranscription): Promise<boolean> {
        try {
          const response = await this.sendTranscription(item.deviceId, item.text);
          return response.success;
        } catch {
          // Network error or timeout
          return false;
        }
      }

      /**
       * Fetch list of connected devices from backend.
       * Returns array of hostnames.
       * Throws on network error or server error.
       */
      async getDevices(): Promise<string[]> {
        const response = await fetch(`${this.baseUrl}/devices`);
        const data = await response.json() as DevicesResponse;

        if (data.success) {
          return data.devices;
        }

        throw new Error('Failed to fetch devices');
      }

      /**
       * Check if backend is reachable.
       * Uses /devices as health check endpoint.
       */
      async healthCheck(): Promise<boolean> {
        try {
          const response = await fetch(`${this.baseUrl}/devices`, {
            method: 'GET',
            // Short timeout for health check
            signal: AbortSignal.timeout(3000),
          });
          return response.ok;
        } catch {
          return false;
        }
      }
    }

    // Singleton instance - baseUrl set when backend discovered
    let apiInstance: ApiClient | null = null;

    /**
     * Get or create API client instance.
     * Must call initApiClient first with valid URL.
     */
    export function getApiClient(): ApiClient {
      if (!apiInstance) {
        throw new Error('API client not initialized. Call initApiClient first.');
      }
      return apiInstance;
    }

    /**
     * Initialize API client with backend URL.
     * Called when backend discovered via mDNS or manual config.
     */
    export function initApiClient(baseUrl: string): ApiClient {
      apiInstance = new ApiClient(baseUrl);
      return apiInstance;
    }

    /**
     * Check if API client is initialized.
     */
    export function isApiClientInitialized(): boolean {
      return apiInstance !== null;
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/services/api.ts | head -30`
    Exports ApiClient: grep for "export class ApiClient"
    Matches backend routes: grep for "/transcription" and "/devices"
  </verify>
  <done>
    API client created matching backend route contracts.
    sendTranscription matches POST /transcription.
    getDevices matches GET /devices.
    Singleton pattern with lazy initialization.
    sendQueuedItem helper for queue replay integration.
  </done>
</task>

</tasks>

<verification>
1. `cat mobile-app/src/services/storage.ts` shows Preferences abstraction
2. `cat mobile-app/src/services/queue.ts` shows queue with persistence
3. `cat mobile-app/src/services/api.ts` shows API client with backend routes
4. `cd mobile-app && npx tsc --noEmit` passes (type checking)
</verification>

<success_criteria>
- Storage service wraps @capacitor/preferences
- Queue service persists immediately on enqueue
- API client matches backend route contracts
- All services export typed functions
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-mobile-app-voice/03-02-SUMMARY.md`
</output>

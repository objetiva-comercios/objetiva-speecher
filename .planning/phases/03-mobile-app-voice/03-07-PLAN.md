---
phase: 03-mobile-app-voice
plan: 07
type: execute
wave: 3
depends_on: ["03-04", "03-05", "03-06"]
files_modified:
  - mobile-app/src/App.tsx
  - mobile-app/src/hooks/useApp.ts
  - mobile-app/android/app/src/main/AndroidManifest.xml
autonomous: true

must_haves:
  truths:
    - "App displays all UI components in proper layout"
    - "Recording flow works: idle -> recording -> editing -> send"
    - "Offline queue replay triggers on reconnect"
    - "Android manifest has required permissions"
    - "App initializes discovery and API client on startup"
  artifacts:
    - path: "mobile-app/src/App.tsx"
      provides: "Main app component with full layout"
      min_lines: 100
    - path: "mobile-app/src/hooks/useApp.ts"
      provides: "App-level state orchestration"
      exports: ["useApp"]
    - path: "mobile-app/android/app/src/main/AndroidManifest.xml"
      provides: "Android permissions"
      contains: "RECORD_AUDIO"
  key_links:
    - from: "mobile-app/src/App.tsx"
      to: "all hooks and components"
      via: "imports and renders"
      pattern: "import.*from.*components"
    - from: "mobile-app/src/hooks/useApp.ts"
      to: "services layer"
      via: "initialization"
      pattern: "initApiClient"
---

<objective>
Integrate all components into the main App with proper layout, state orchestration, and Android configuration.

Purpose: Create the complete working mobile app by connecting all previously built components and services.
Output: Working App.tsx with full recording/sending flow and properly configured Android project.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-mobile-app-voice/03-CONTEXT.md
@.planning/phases/03-mobile-app-voice/03-RESEARCH.md
@mobile-app/src/types/index.ts
@mobile-app/src/services/discovery.ts
@mobile-app/src/services/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useApp orchestration hook</name>
  <files>
    mobile-app/src/hooks/useApp.ts
  </files>
  <action>
    Create useApp hook to orchestrate app-level state and initialization.
    Handles discovery, API initialization, and coordinates reconnect logic.

    ```typescript
    import { useState, useEffect, useCallback } from 'react';
    import { initializeDiscovery, getBackendUrl, setManualBackendUrl } from '../services/discovery';
    import { initApiClient, getApiClient, isApiClientInitialized } from '../services/api';
    import { setReconnecting } from '../services/network';

    type AppState = 'initializing' | 'configuring' | 'ready' | 'error';

    interface UseAppResult {
      state: AppState;
      error: string | null;
      backendUrl: string | null;
      setManualUrl: (url: string) => Promise<void>;
      isReady: boolean;
    }

    /**
     * App-level orchestration hook.
     * Handles initialization, discovery, and API client setup.
     */
    export function useApp(): UseAppResult {
      const [state, setState] = useState<AppState>('initializing');
      const [error, setError] = useState<string | null>(null);
      const [backendUrl, setBackendUrl] = useState<string | null>(null);

      // Initialize on mount
      useEffect(() => {
        const init = async () => {
          try {
            setState('initializing');

            // Attempt discovery (mDNS or stored URL)
            const url = await initializeDiscovery();

            if (url) {
              initApiClient(url);
              setBackendUrl(url);

              // Verify backend is reachable
              const api = getApiClient();
              const healthy = await api.healthCheck();

              if (healthy) {
                setState('ready');
              } else {
                setState('configuring');
                setError('No se puede conectar al servidor');
              }
            } else {
              // No backend found - need manual config
              setState('configuring');
            }
          } catch (err: any) {
            setError(err.message || 'Error de inicializacion');
            setState('error');
          }
        };

        init();
      }, []);

      // Set manual backend URL
      const setManualUrl = useCallback(async (url: string) => {
        try {
          await setManualBackendUrl(url);
          initApiClient(url);
          setBackendUrl(url);

          // Verify it works
          const api = getApiClient();
          const healthy = await api.healthCheck();

          if (healthy) {
            setState('ready');
            setError(null);
          } else {
            setError('No se puede conectar a esa direccion');
          }
        } catch (err: any) {
          setError(err.message || 'URL invalida');
        }
      }, []);

      return {
        state,
        error,
        backendUrl,
        setManualUrl,
        isReady: state === 'ready',
      };
    }

    /**
     * Handle reconnection after offline period.
     * Called when network status changes to online.
     */
    export async function handleReconnect(replayQueue: () => Promise<number>): Promise<void> {
      if (!isApiClientInitialized()) {
        setReconnecting(false);
        return;
      }

      try {
        const api = getApiClient();
        const healthy = await api.healthCheck();

        if (healthy) {
          // Backend reachable - replay queue
          await replayQueue();
        }
      } finally {
        setReconnecting(false);
      }
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/hooks/useApp.ts | head -40`
    Initializes discovery: grep for "initializeDiscovery"
    Creates API client: grep for "initApiClient"
  </verify>
  <done>
    useApp hook handles app initialization.
    Attempts mDNS discovery on startup.
    Falls back to configuring state if no backend found.
    handleReconnect triggers queue replay on reconnect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create main App component with full layout</name>
  <files>
    mobile-app/src/App.tsx
  </files>
  <action>
    Create complete App.tsx integrating all components.
    Per user decisions:
    - Dropdown selector always visible on main screen
    - Status indicator near device selector (not header bar)
    - Offline state: banner + disabled recording button
    - When no devices connected: empty state message, disable recording

    ```tsx
    import { useState, useCallback } from 'react';
    import { useApp, handleReconnect } from './hooks/useApp';
    import { useNetworkStatus } from './hooks/useNetworkStatus';
    import { useDeviceList } from './hooks/useDeviceList';
    import { useSpeechRecognition } from './hooks/useSpeechRecognition';
    import { useQueue } from './hooks/useQueue';
    import { getApiClient, isApiClientInitialized } from './services/api';

    import { DeviceSelector } from './components/DeviceSelector';
    import { StatusIndicator } from './components/StatusIndicator';
    import { OfflineBanner } from './components/OfflineBanner';
    import { RecordButton } from './components/RecordButton';
    import { RecordingTimer } from './components/RecordingTimer';
    import { WaveformVisualizer } from './components/WaveformVisualizer';
    import { TranscriptionEditor } from './components/TranscriptionEditor';
    import { QueueList } from './components/QueueList';
    import { SuccessFeedback } from './components/SuccessFeedback';

    function App() {
      const { state: appState, error: appError, setManualUrl, isReady } = useApp();
      const [showSuccess, setShowSuccess] = useState(false);
      const [isSending, setIsSending] = useState(false);

      // Queue hook
      const { items: queueItems, addToQueue, removeFromQueue, replayAll, isReplaying } = useQueue();

      // Network status with reconnect handler
      const { status: networkStatus, isOnline } = useNetworkStatus(
        // onOnline - trigger queue replay
        useCallback(() => {
          handleReconnect(replayAll);
        }, [replayAll]),
        // onOffline
        undefined
      );

      // Device list
      const {
        devices,
        selectedDevice,
        selectDevice,
        isLoading: devicesLoading,
        hasDevices,
      } = useDeviceList();

      // Speech recognition
      const {
        state: recordingState,
        liveText,
        finalText,
        error: speechError,
        recordingDuration,
        startRecording,
        stopRecording,
        setFinalText,
        clearError,
        resetToIdle,
      } = useSpeechRecognition();

      // Determine if recording should be disabled
      const isRecordingDisabled = !isOnline || !hasDevices || !isReady;

      // Handle send transcription
      const handleSend = useCallback(async () => {
        if (!selectedDevice || !finalText.trim() || !isApiClientInitialized()) {
          return;
        }

        setIsSending(true);
        try {
          const api = getApiClient();
          const response = await api.sendTranscription(selectedDevice, finalText.trim());

          if (response.success) {
            // Show success feedback
            setShowSuccess(true);
            resetToIdle();
          } else {
            // Queue for later
            await addToQueue(selectedDevice, finalText.trim());
            resetToIdle();
          }
        } catch {
          // Network error - queue it
          await addToQueue(selectedDevice, finalText.trim());
          resetToIdle();
        } finally {
          setIsSending(false);
        }
      }, [selectedDevice, finalText, addToQueue, resetToIdle]);

      // Handle cancel editing
      const handleCancel = useCallback(() => {
        clearError();
        resetToIdle();
      }, [clearError, resetToIdle]);

      // Show config screen if backend not configured
      if (appState === 'configuring') {
        return <ConfigScreen onSubmit={setManualUrl} error={appError} />;
      }

      // Show loading while initializing
      if (appState === 'initializing') {
        return (
          <div className="min-h-screen bg-gray-100 flex items-center justify-center">
            <div className="text-center">
              <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto" />
              <p className="mt-4 text-gray-600">Conectando...</p>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gray-100 p-4">
          {/* Header with device selector and status */}
          <header className="mb-6">
            <h1 className="text-xl font-bold text-gray-800 mb-4">
              Objetiva Speecher
            </h1>

            {/* Status indicator near device selector per user decision */}
            <div className="flex items-center justify-between mb-3">
              <StatusIndicator status={networkStatus} />
            </div>

            {/* Device selector always visible per user decision */}
            <DeviceSelector
              devices={devices}
              selectedDevice={selectedDevice}
              onSelect={selectDevice}
              isLoading={devicesLoading}
              disabled={!isOnline}
            />
          </header>

          {/* Offline banner per user decision */}
          <OfflineBanner status={networkStatus} />

          {/* Main recording area */}
          <main className="space-y-6">
            {/* Waveform and timer during recording */}
            {recordingState === 'recording' && (
              <div className="text-center space-y-4">
                <WaveformVisualizer isRecording={true} />
                <RecordingTimer seconds={recordingDuration} />
              </div>
            )}

            {/* Transcription area */}
            <TranscriptionEditor
              text={finalText}
              liveText={liveText}
              isRecording={recordingState === 'recording'}
              isEditing={recordingState === 'editing'}
              error={speechError}
              onTextChange={setFinalText}
              onSend={handleSend}
              onCancel={handleCancel}
              isSending={isSending}
            />

            {/* Record button - centered when visible */}
            {recordingState !== 'editing' && (
              <div className="flex justify-center">
                <RecordButton
                  state={recordingState}
                  onStart={startRecording}
                  onStop={stopRecording}
                  disabled={isRecordingDisabled}
                />
              </div>
            )}

            {/* Disabled reason hint */}
            {isRecordingDisabled && recordingState === 'idle' && (
              <p className="text-center text-gray-400 text-sm">
                {!isOnline
                  ? 'Sin conexion'
                  : !hasDevices
                  ? 'No hay dispositivos conectados'
                  : 'Conectando...'}
              </p>
            )}

            {/* Queue list */}
            <QueueList
              items={queueItems}
              onDelete={removeFromQueue}
              isReplaying={isReplaying}
            />
          </main>

          {/* Success feedback */}
          <SuccessFeedback
            show={showSuccess}
            onComplete={() => setShowSuccess(false)}
          />
        </div>
      );
    }

    // Config screen for manual backend URL entry
    interface ConfigScreenProps {
      onSubmit: (url: string) => void;
      error: string | null;
    }

    function ConfigScreen({ onSubmit, error }: ConfigScreenProps) {
      const [url, setUrl] = useState('');

      const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (url.trim()) {
          onSubmit(url.trim());
        }
      };

      return (
        <div className="min-h-screen bg-gray-100 p-4 flex flex-col justify-center">
          <div className="max-w-sm mx-auto w-full">
            <h1 className="text-xl font-bold text-gray-800 mb-2 text-center">
              Objetiva Speecher
            </h1>
            <p className="text-gray-600 text-center mb-6">
              Ingresa la direccion del servidor
            </p>

            <form onSubmit={handleSubmit} className="space-y-4">
              <input
                type="text"
                value={url}
                onChange={(e) => setUrl(e.target.value)}
                placeholder="http://192.168.1.100:3000"
                className="
                  w-full p-3 rounded-lg border border-gray-300
                  focus:ring-2 focus:ring-blue-500 focus:border-blue-500
                "
              />

              {error && (
                <p className="text-red-600 text-sm">{error}</p>
              )}

              <button
                type="submit"
                disabled={!url.trim()}
                className="
                  w-full py-3 px-4 rounded-lg
                  bg-blue-500 text-white font-medium
                  hover:bg-blue-600
                  disabled:opacity-50 disabled:cursor-not-allowed
                "
              >
                Conectar
              </button>
            </form>

            <p className="text-gray-400 text-xs text-center mt-6">
              Inicia el servidor en tu PC y asegurate de estar en la misma red WiFi
            </p>
          </div>
        </div>
      );
    }

    export default App;
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/App.tsx | head -50`
    Imports all components: grep for "import.*components"
    Has config screen: grep for "ConfigScreen"
  </verify>
  <done>
    App.tsx integrates all components.
    Handles initialization, config, and ready states.
    Recording flow: idle -> recording -> editing -> send.
    Queue replay triggered on reconnect.
    Manual backend URL config if discovery fails.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure Android permissions and sync</name>
  <files>
    mobile-app/android/app/src/main/AndroidManifest.xml
  </files>
  <action>
    Update Android manifest with required permissions per research.
    Then sync and build Android project.

    1. Read current AndroidManifest.xml and add permissions if missing:
       - RECORD_AUDIO (for speech recognition)
       - INTERNET (for network requests)
       - ACCESS_NETWORK_STATE (for network monitoring)
       - ACCESS_WIFI_STATE (for mDNS)
       - CHANGE_WIFI_MULTICAST_STATE (for mDNS discovery)

    2. The manifest should include inside <manifest> before <application>:
    ```xml
    <!-- Speech recognition -->
    <uses-permission android:name="android.permission.RECORD_AUDIO" />

    <!-- Network operations -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- mDNS discovery -->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE" />
    ```

    3. Build and sync:
    ```bash
    cd mobile-app
    npm run build
    npx cap sync
    ```

    4. Verify sync completed successfully.
  </action>
  <verify>
    Permissions in manifest: grep for "RECORD_AUDIO" in AndroidManifest.xml
    Sync completed: `ls mobile-app/android/app/build` or check cap sync output
  </verify>
  <done>
    AndroidManifest.xml has all required permissions.
    RECORD_AUDIO for speech recognition.
    Network permissions for API calls.
    WiFi permissions for mDNS discovery.
    Project synced with native code.
  </done>
</task>

</tasks>

<verification>
1. `cat mobile-app/src/hooks/useApp.ts` shows initialization logic
2. `cat mobile-app/src/App.tsx` shows complete app with all components
3. `grep -r "RECORD_AUDIO" mobile-app/android/` shows permission
4. `cd mobile-app && npm run build` succeeds
5. `cd mobile-app && npx cap sync` succeeds
</verification>

<success_criteria>
- useApp handles initialization and discovery
- App.tsx renders complete UI with all components
- Recording flow works through all states
- Config screen shown if backend not discovered
- Queue replay triggered on network reconnect
- Android manifest has all required permissions
- Project builds and syncs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-mobile-app-voice/03-07-SUMMARY.md`
</output>

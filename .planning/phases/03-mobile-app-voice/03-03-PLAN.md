---
phase: 03-mobile-app-voice
plan: 03
type: execute
wave: 1
depends_on: ["03-01"]
files_modified:
  - mobile-app/src/services/network.ts
  - mobile-app/src/services/discovery.ts
  - mobile-app/src/services/speech.ts
autonomous: true

must_haves:
  truths:
    - "App detects online/offline status changes"
    - "App can discover backend via mDNS or use manual fallback"
    - "Speech recognition captures partial results during dictation"
    - "Speech recognition errors show Spanish messages"
  artifacts:
    - path: "mobile-app/src/services/network.ts"
      provides: "Network status monitoring"
      exports: ["checkNetworkStatus", "startNetworkMonitoring", "stopNetworkMonitoring"]
    - path: "mobile-app/src/services/discovery.ts"
      provides: "Backend discovery via mDNS with fallback"
      exports: ["discoverBackend", "setManualBackendUrl", "getBackendUrl"]
    - path: "mobile-app/src/services/speech.ts"
      provides: "Speech recognition abstraction"
      exports: ["requestSpeechPermission", "startListening", "stopListening", "ERROR_MESSAGES_ES"]
  key_links:
    - from: "mobile-app/src/services/speech.ts"
      to: "@capgo/capacitor-speech-recognition"
      via: "import { SpeechRecognition }"
      pattern: "SpeechRecognition"
    - from: "mobile-app/src/services/network.ts"
      to: "@capacitor/network"
      via: "import { Network }"
      pattern: "Network"
---

<objective>
Create network monitoring, backend discovery, and speech recognition services for the mobile app.

Purpose: Enable connectivity awareness, automatic backend detection, and voice capture functionality.
Output: Network, discovery, and speech services ready for use by hooks and components.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-mobile-app-voice/03-RESEARCH.md
@mobile-app/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create network status monitoring service</name>
  <files>
    mobile-app/src/services/network.ts
  </files>
  <action>
    Create network.ts with @capacitor/network integration.
    Per user decision: show "Reconnecting..." state, offline banner, disabled recording when offline.

    ```typescript
    import { Network, type ConnectionStatus } from '@capacitor/network';
    import type { ConnectionStatus as AppConnectionStatus } from '../types';

    type NetworkCallback = (status: AppConnectionStatus) => void;

    let isOnline = true;
    let isReconnecting = false;
    let listeners: NetworkCallback[] = [];

    /**
     * Check current network status.
     * Returns true if connected to network.
     */
    export async function checkNetworkStatus(): Promise<boolean> {
      const status = await Network.getStatus();
      isOnline = status.connected;
      return isOnline;
    }

    /**
     * Get current connection status for UI.
     */
    export function getConnectionStatus(): AppConnectionStatus {
      if (isReconnecting) return 'reconnecting';
      return isOnline ? 'online' : 'offline';
    }

    /**
     * Set reconnecting state.
     * Called when attempting to reconnect to backend after offline period.
     */
    export function setReconnecting(reconnecting: boolean): void {
      isReconnecting = reconnecting;
      notifyListeners();
    }

    /**
     * Start monitoring network status changes.
     * Calls onOnline when connection restores (triggers queue replay).
     * Calls onOffline when connection drops (shows offline banner).
     */
    export function startNetworkMonitoring(
      onOnline: () => void,
      onOffline: () => void
    ): void {
      Network.addListener('networkStatusChange', (status: ConnectionStatus) => {
        const wasOffline = !isOnline;
        isOnline = status.connected;

        if (isOnline && wasOffline) {
          // Connection restored
          isReconnecting = true;
          notifyListeners();
          onOnline();
        } else if (!isOnline) {
          // Connection lost
          isReconnecting = false;
          notifyListeners();
          onOffline();
        }
      });
    }

    /**
     * Stop monitoring network status.
     * Call when component unmounts or app goes to background.
     */
    export function stopNetworkMonitoring(): void {
      Network.removeAllListeners();
      listeners = [];
    }

    /**
     * Subscribe to connection status changes.
     * Returns unsubscribe function.
     */
    export function subscribeToNetworkStatus(callback: NetworkCallback): () => void {
      listeners.push(callback);
      // Immediately call with current status
      callback(getConnectionStatus());
      return () => {
        listeners = listeners.filter(l => l !== callback);
      };
    }

    /**
     * Notify all listeners of status change.
     */
    function notifyListeners(): void {
      const status = getConnectionStatus();
      listeners.forEach(l => l(status));
    }

    /**
     * Check if currently online.
     */
    export function isCurrentlyOnline(): boolean {
      return isOnline;
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/services/network.ts | head -30`
    Uses @capacitor/network: grep for "import.*Network"
    Exports monitoring functions: grep for "export"
  </verify>
  <done>
    Network service created with @capacitor/network integration.
    Supports online/offline/reconnecting states per user decision.
    Listener pattern for UI subscription.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backend discovery service</name>
  <files>
    mobile-app/src/services/discovery.ts
  </files>
  <action>
    Create discovery.ts with mDNS discovery and manual fallback.
    Per research: backend may not have mDNS yet, so manual IP fallback is critical.
    Per research pitfall #5: handle mDNS timeout gracefully.

    ```typescript
    import { Zeroconf, type ZeroConfWatchResult } from 'capacitor-zeroconf';
    import type { BackendService } from '../types';
    import { getItem, setItem, STORAGE_KEYS } from './storage';

    const SERVICE_TYPE = '_speecher._tcp.';
    const DOMAIN = 'local.';
    const DISCOVERY_TIMEOUT_MS = 10000;  // 10 seconds

    let discoveredBackend: BackendService | null = null;
    let manualBackendUrl: string | null = null;

    /**
     * Attempt to discover backend via mDNS.
     * Times out after 10 seconds and falls back to stored/manual URL.
     * Returns discovered service or null.
     */
    export async function discoverBackend(): Promise<BackendService | null> {
      return new Promise((resolve) => {
        let resolved = false;

        const timeout = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            Zeroconf.unwatch({ type: SERVICE_TYPE, domain: DOMAIN }).catch(() => {});
            resolve(null);
          }
        }, DISCOVERY_TIMEOUT_MS);

        Zeroconf.watch(
          { type: SERVICE_TYPE, domain: DOMAIN },
          (result: ZeroConfWatchResult) => {
            if (result.action === 'resolved' && !resolved) {
              resolved = true;
              clearTimeout(timeout);

              const ip = result.service.ipv4Addresses?.[0] || result.service.ipv6Addresses?.[0];
              if (ip) {
                discoveredBackend = {
                  hostname: result.service.hostname || 'unknown',
                  ip,
                  port: result.service.port,
                  url: `http://${ip}:${result.service.port}`,
                };
                resolve(discoveredBackend);
              } else {
                resolve(null);
              }

              Zeroconf.unwatch({ type: SERVICE_TYPE, domain: DOMAIN }).catch(() => {});
            }
          }
        ).catch(() => {
          if (!resolved) {
            resolved = true;
            clearTimeout(timeout);
            resolve(null);
          }
        });
      });
    }

    /**
     * Stop watching for mDNS services.
     */
    export async function stopDiscovery(): Promise<void> {
      try {
        await Zeroconf.unwatch({ type: SERVICE_TYPE, domain: DOMAIN });
      } catch {
        // Ignore errors on cleanup
      }
    }

    /**
     * Set manual backend URL.
     * Persists to storage for future app launches.
     */
    export async function setManualBackendUrl(url: string): Promise<void> {
      manualBackendUrl = url;
      await setItem(STORAGE_KEYS.BACKEND_URL, url);
    }

    /**
     * Get stored manual backend URL.
     */
    export async function getStoredBackendUrl(): Promise<string | null> {
      return getItem(STORAGE_KEYS.BACKEND_URL);
    }

    /**
     * Get current backend URL.
     * Priority: manual URL > discovered URL > stored URL > null
     */
    export function getBackendUrl(): string | null {
      if (manualBackendUrl) return manualBackendUrl;
      if (discoveredBackend) return discoveredBackend.url;
      return null;
    }

    /**
     * Initialize discovery service.
     * Loads stored URL and attempts mDNS discovery.
     * Returns the determined backend URL or null if not found.
     */
    export async function initializeDiscovery(): Promise<string | null> {
      // First, load any stored manual URL
      const storedUrl = await getStoredBackendUrl();
      if (storedUrl) {
        manualBackendUrl = storedUrl;
      }

      // Attempt mDNS discovery
      const discovered = await discoverBackend();

      // Return best available URL
      if (discovered) {
        return discovered.url;
      }
      return manualBackendUrl;
    }

    /**
     * Check if backend URL is configured (either discovered or manual).
     */
    export function isBackendConfigured(): boolean {
      return getBackendUrl() !== null;
    }

    /**
     * Get discovered backend info (for display purposes).
     */
    export function getDiscoveredBackend(): BackendService | null {
      return discoveredBackend;
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/services/discovery.ts | head -30`
    Uses capacitor-zeroconf: grep for "import.*Zeroconf"
    Has fallback to manual URL: grep for "manualBackendUrl"
  </verify>
  <done>
    Discovery service created with mDNS and manual fallback.
    10-second timeout for mDNS per research.
    Persists manual URL to storage.
    Priority: manual > discovered > stored.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create speech recognition service</name>
  <files>
    mobile-app/src/services/speech.ts
  </files>
  <action>
    Create speech.ts with @capgo/capacitor-speech-recognition integration.
    Per user decision: tap to start/stop, live streaming text.
    Per research: popup: false required for partialResults on Android.
    Per research pitfall #6: handle all error codes with Spanish messages.

    ```typescript
    import { SpeechRecognition } from '@capgo/capacitor-speech-recognition';
    import type { SpeechError } from '../types';

    /**
     * Spanish error messages for all SpeechRecognizer error codes.
     * Per research pitfall #6: handle all 13+ error codes explicitly.
     */
    export const ERROR_MESSAGES_ES: Record<number, string> = {
      1: 'Error de red. Verifica tu conexion.',
      2: 'Error de red. Verifica tu conexion.',
      3: 'Error de audio. Verifica el microfono.',
      4: 'Error del servidor de reconocimiento.',
      5: 'Error interno. Intenta de nuevo.',
      6: 'No se detecto voz. Habla mas fuerte.',
      7: 'No se reconocio el texto. Intenta de nuevo.',
      8: 'Reconocimiento ocupado. Espera un momento.',
      9: 'Permiso de microfono denegado.',
      10: 'Error de permisos. Verifica configuracion.',
      11: 'Error del servicio. Intenta de nuevo.',
      12: 'Idioma no soportado en este dispositivo.',
      13: 'Idioma no disponible. Descargalo en configuracion.',
    };

    /**
     * Get Spanish error message for error code.
     * Falls back to generic message for unknown codes.
     */
    export function getErrorMessage(errorCode: number): string {
      return ERROR_MESSAGES_ES[errorCode] || 'Error desconocido. Intenta de nuevo.';
    }

    type PartialResultsCallback = (text: string) => void;
    type ErrorCallback = (error: SpeechError) => void;
    type ListeningStateCallback = (isListening: boolean) => void;

    let partialCallback: PartialResultsCallback | null = null;
    let errorCallback: ErrorCallback | null = null;
    let listeningCallback: ListeningStateCallback | null = null;

    /**
     * Request microphone permission for speech recognition.
     * Returns true if granted.
     */
    export async function requestSpeechPermission(): Promise<boolean> {
      const result = await SpeechRecognition.requestPermissions();
      return result.speechRecognition === 'granted';
    }

    /**
     * Check if speech recognition permission is granted.
     */
    export async function checkSpeechPermission(): Promise<boolean> {
      const result = await SpeechRecognition.checkPermissions();
      return result.speechRecognition === 'granted';
    }

    /**
     * Check if speech recognition is available on this device.
     */
    export async function isSpeechAvailable(): Promise<boolean> {
      const result = await SpeechRecognition.available();
      return result.available;
    }

    /**
     * Setup listeners for speech recognition events.
     * Must be called before startListening.
     */
    export function setupSpeechListeners(
      onPartialResults: PartialResultsCallback,
      onError: ErrorCallback,
      onListeningState?: ListeningStateCallback
    ): void {
      partialCallback = onPartialResults;
      errorCallback = onError;
      listeningCallback = onListeningState || null;

      // Remove any existing listeners first
      SpeechRecognition.removeAllListeners();

      // Partial results - streaming text as user speaks
      SpeechRecognition.addListener('partialResults', (data: { matches: string[] }) => {
        const text = data.matches[0] || '';
        partialCallback?.(text);
      });

      // Error handling with Spanish messages
      SpeechRecognition.addListener('error', (error: { error: number }) => {
        const message = getErrorMessage(error.error);
        errorCallback?.({ code: error.error, message });
      });

      // Listening state changes
      SpeechRecognition.addListener('listeningState', (data: { status: string }) => {
        const isListening = data.status === 'started';
        listeningCallback?.(isListening);
      });
    }

    /**
     * Start speech recognition.
     * Per research: popup: false is CRITICAL for partialResults on Android.
     * Language hardcoded to es-AR per project constraints.
     */
    export async function startListening(): Promise<void> {
      await SpeechRecognition.start({
        language: 'es-AR',
        partialResults: true,
        popup: false,  // CRITICAL: must be false for partialResults on Android
        maxResults: 1,
      });
    }

    /**
     * Stop speech recognition.
     * The final result should come from the last partial result.
     */
    export async function stopListening(): Promise<void> {
      await SpeechRecognition.stop();
    }

    /**
     * Check if currently listening.
     */
    export async function isListening(): Promise<boolean> {
      const state = await SpeechRecognition.isListening();
      return state.listening;
    }

    /**
     * Cleanup speech recognition listeners.
     * Call when component unmounts.
     */
    export function cleanupSpeechListeners(): void {
      SpeechRecognition.removeAllListeners();
      partialCallback = null;
      errorCallback = null;
      listeningCallback = null;
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/services/speech.ts | head -40`
    Uses @capgo plugin: grep for "import.*SpeechRecognition"
    popup: false set: grep for "popup: false"
    Spanish error messages: grep for "ERROR_MESSAGES_ES"
  </verify>
  <done>
    Speech service created with @capgo/capacitor-speech-recognition.
    popup: false configured for partialResults per research.
    All 13 error codes mapped to Spanish messages.
    Listener pattern for partial results, errors, and listening state.
    Language hardcoded to es-AR per project constraints.
  </done>
</task>

</tasks>

<verification>
1. `cat mobile-app/src/services/network.ts` shows Network plugin usage
2. `cat mobile-app/src/services/discovery.ts` shows mDNS + manual fallback
3. `cat mobile-app/src/services/speech.ts` shows SpeechRecognition with popup: false
4. `cd mobile-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- Network service detects online/offline/reconnecting states
- Discovery service attempts mDNS with 10s timeout
- Discovery service falls back to stored manual URL
- Speech service uses popup: false for partialResults
- All speech errors have Spanish translations
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-mobile-app-voice/03-03-SUMMARY.md`
</output>

---
phase: 03-mobile-app-voice
plan: 06
type: execute
wave: 2
depends_on: ["03-02", "03-03"]
files_modified:
  - mobile-app/src/hooks/useQueue.ts
  - mobile-app/src/components/TranscriptionEditor.tsx
  - mobile-app/src/components/QueueList.tsx
  - mobile-app/src/components/SuccessFeedback.tsx
autonomous: true

must_haves:
  truths:
    - "User can edit transcription before sending"
    - "User sees visible pending queue list"
    - "User can swipe to delete queued items"
    - "User sees brief success feedback on delivery"
    - "Speech recognition errors show inline in transcription area"
  artifacts:
    - path: "mobile-app/src/components/TranscriptionEditor.tsx"
      provides: "Editable text field with send button"
      min_lines: 40
    - path: "mobile-app/src/components/QueueList.tsx"
      provides: "Pending transcriptions with swipe-to-delete"
      min_lines: 40
    - path: "mobile-app/src/hooks/useQueue.ts"
      provides: "Queue state and operations hook"
      exports: ["useQueue"]
  key_links:
    - from: "mobile-app/src/hooks/useQueue.ts"
      to: "mobile-app/src/services/queue.ts"
      via: "import { loadQueue, enqueue, dequeue }"
      pattern: "loadQueue"
    - from: "mobile-app/src/components/QueueList.tsx"
      to: "mobile-app/src/hooks/useQueue.ts"
      via: "useQueue()"
      pattern: "useQueue"
---

<objective>
Create transcription editing, queue display, and success feedback UI components.

Purpose: Enable user to edit transcriptions before sending, view queued items, and see delivery feedback.
Output: TranscriptionEditor, QueueList, SuccessFeedback components with useQueue hook.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-mobile-app-voice/03-CONTEXT.md
@.planning/phases/03-mobile-app-voice/03-RESEARCH.md
@mobile-app/src/types/index.ts
@mobile-app/src/services/queue.ts
@mobile-app/src/services/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useQueue hook for queue state management</name>
  <files>
    mobile-app/src/hooks/useQueue.ts
  </files>
  <action>
    Create useQueue hook for managing queue state and operations.
    Per user decision: visible pending list, swipe to delete.

    ```typescript
    import { useState, useEffect, useCallback } from 'react';
    import type { QueuedTranscription } from '../types';
    import { loadQueue, enqueue, dequeue, replayQueue } from '../services/queue';
    import { getApiClient, isApiClientInitialized } from '../services/api';

    interface UseQueueResult {
      items: QueuedTranscription[];
      isReplaying: boolean;
      addToQueue: (deviceId: string, text: string) => Promise<QueuedTranscription>;
      removeFromQueue: (id: string) => Promise<void>;
      replayAll: () => Promise<number>;
      refresh: () => Promise<void>;
      queueLength: number;
    }

    /**
     * Hook for managing the transcription queue.
     * Per user decision:
     * - Queue transcriptions when target device is offline
     * - Show visible pending list of queued items
     * - Swipe to delete queued transcriptions
     */
    export function useQueue(): UseQueueResult {
      const [items, setItems] = useState<QueuedTranscription[]>([]);
      const [isReplaying, setIsReplaying] = useState(false);

      // Load queue on mount
      const refresh = useCallback(async () => {
        const queue = await loadQueue();
        setItems(queue);
      }, []);

      useEffect(() => {
        refresh();
      }, [refresh]);

      // Add item to queue
      const addToQueue = useCallback(async (deviceId: string, text: string): Promise<QueuedTranscription> => {
        const item = await enqueue(deviceId, text);
        await refresh();
        return item;
      }, [refresh]);

      // Remove item from queue (swipe to delete)
      const removeFromQueue = useCallback(async (id: string): Promise<void> => {
        await dequeue(id);
        await refresh();
      }, [refresh]);

      // Replay all queued items
      const replayAll = useCallback(async (): Promise<number> => {
        if (!isApiClientInitialized()) {
          return 0;
        }

        setIsReplaying(true);
        try {
          const api = getApiClient();
          const sentCount = await replayQueue(async (item) => {
            return api.sendQueuedItem(item);
          });
          await refresh();
          return sentCount;
        } finally {
          setIsReplaying(false);
        }
      }, [refresh]);

      return {
        items,
        isReplaying,
        addToQueue,
        removeFromQueue,
        replayAll,
        refresh,
        queueLength: items.length,
      };
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/hooks/useQueue.ts | head -40`
    Uses queue service: grep for "import.*from.*queue"
    Has swipe to delete: grep for "removeFromQueue"
  </verify>
  <done>
    useQueue hook manages queue state.
    addToQueue adds and persists items.
    removeFromQueue supports swipe-to-delete.
    replayAll sends all queued items on reconnect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TranscriptionEditor and SuccessFeedback components</name>
  <files>
    mobile-app/src/components/TranscriptionEditor.tsx
    mobile-app/src/components/SuccessFeedback.tsx
  </files>
  <action>
    Create TranscriptionEditor for editing text before send, and SuccessFeedback for delivery confirmation.
    Per user decision:
    - After stop: editable text field before send/confirm
    - Brief success feedback (checkmark/green flash) on delivery
    - Speech recognition errors: inline message in transcription area

    1. Create src/components/SuccessFeedback.tsx:
    ```tsx
    import { useEffect, useState } from 'react';

    interface SuccessFeedbackProps {
      show: boolean;
      onComplete: () => void;
    }

    /**
     * Brief success feedback animation.
     * Per user decision: checkmark/green flash on delivery.
     */
    export function SuccessFeedback({ show, onComplete }: SuccessFeedbackProps) {
      const [visible, setVisible] = useState(false);

      useEffect(() => {
        if (show) {
          setVisible(true);
          const timer = setTimeout(() => {
            setVisible(false);
            onComplete();
          }, 1500);
          return () => clearTimeout(timer);
        }
      }, [show, onComplete]);

      if (!visible) return null;

      return (
        <div className="fixed inset-0 flex items-center justify-center z-50 pointer-events-none">
          <div className="bg-green-500 text-white rounded-full p-6 animate-success">
            <svg
              className="w-12 h-12"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={3}
                d="M5 13l4 4L19 7"
              />
            </svg>
          </div>
          <style>{`
            @keyframes success {
              0% {
                transform: scale(0);
                opacity: 0;
              }
              50% {
                transform: scale(1.1);
                opacity: 1;
              }
              100% {
                transform: scale(1);
                opacity: 1;
              }
            }
            .animate-success {
              animation: success 0.3s ease-out;
            }
          `}</style>
        </div>
      );
    }
    ```

    2. Create src/components/TranscriptionEditor.tsx:
    ```tsx
    import { useState, useEffect } from 'react';
    import type { SpeechError } from '../types';

    interface TranscriptionEditorProps {
      text: string;
      liveText: string;
      isRecording: boolean;
      isEditing: boolean;
      error: SpeechError | null;
      onTextChange: (text: string) => void;
      onSend: () => void;
      onCancel: () => void;
      isSending: boolean;
    }

    /**
     * Transcription display and editor.
     * Per user decision:
     * - Live streaming text as speech is recognized (word-by-word updates)
     * - After stop: editable text field before send/confirm
     * - Speech recognition errors: inline message in transcription area
     */
    export function TranscriptionEditor({
      text,
      liveText,
      isRecording,
      isEditing,
      error,
      onTextChange,
      onSend,
      onCancel,
      isSending,
    }: TranscriptionEditorProps) {
      const [editedText, setEditedText] = useState(text);

      // Sync with prop when entering editing mode
      useEffect(() => {
        if (isEditing) {
          setEditedText(text);
        }
      }, [isEditing, text]);

      // Show error inline
      if (error) {
        return (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4">
            <p className="text-red-700">{error.message}</p>
            <button
              onClick={onCancel}
              className="mt-2 text-red-600 text-sm underline"
            >
              Intentar de nuevo
            </button>
          </div>
        );
      }

      // Recording mode - show live text
      if (isRecording) {
        return (
          <div className="bg-gray-50 rounded-lg p-4 min-h-24">
            <p className="text-gray-700">
              {liveText || <span className="text-gray-400 italic">Escuchando...</span>}
            </p>
          </div>
        );
      }

      // Editing mode - show editable text field
      if (isEditing) {
        return (
          <div className="space-y-4">
            <textarea
              value={editedText}
              onChange={(e) => {
                setEditedText(e.target.value);
                onTextChange(e.target.value);
              }}
              className="
                w-full p-4 rounded-lg border border-gray-300
                focus:ring-2 focus:ring-blue-500 focus:border-blue-500
                min-h-32 resize-none
                text-gray-800
              "
              placeholder="Edita el texto aqui..."
              disabled={isSending}
            />
            <div className="flex gap-3">
              <button
                onClick={onCancel}
                disabled={isSending}
                className="
                  flex-1 py-3 px-4 rounded-lg
                  border border-gray-300 text-gray-700
                  hover:bg-gray-50
                  disabled:opacity-50 disabled:cursor-not-allowed
                "
              >
                Cancelar
              </button>
              <button
                onClick={onSend}
                disabled={isSending || !editedText.trim()}
                className="
                  flex-1 py-3 px-4 rounded-lg
                  bg-blue-500 text-white font-medium
                  hover:bg-blue-600
                  disabled:opacity-50 disabled:cursor-not-allowed
                  flex items-center justify-center gap-2
                "
              >
                {isSending ? (
                  <>
                    <span className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                    Enviando...
                  </>
                ) : (
                  'Enviar'
                )}
              </button>
            </div>
          </div>
        );
      }

      // Idle mode - show placeholder
      return (
        <div className="bg-gray-50 rounded-lg p-4 min-h-24">
          <p className="text-gray-400 italic text-center">
            Toca el boton para empezar a grabar
          </p>
        </div>
      );
    }
    ```
  </action>
  <verify>
    Files exist: `ls mobile-app/src/components/TranscriptionEditor.tsx mobile-app/src/components/SuccessFeedback.tsx`
    TranscriptionEditor has editing: grep for "isEditing"
    SuccessFeedback has animation: grep for "animate-success"
  </verify>
  <done>
    TranscriptionEditor shows live text during recording.
    TranscriptionEditor provides editable textarea after stop.
    TranscriptionEditor shows errors inline.
    SuccessFeedback shows checkmark animation on delivery.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create QueueList component with swipe-to-delete</name>
  <files>
    mobile-app/src/components/QueueList.tsx
  </files>
  <action>
    Create QueueList showing pending transcriptions with swipe-to-delete.
    Per user decision:
    - Show visible pending list of queued items
    - Swipe to delete queued transcriptions

    ```tsx
    import { useState, useRef } from 'react';
    import type { QueuedTranscription } from '../types';

    interface QueueListProps {
      items: QueuedTranscription[];
      onDelete: (id: string) => void;
      isReplaying: boolean;
    }

    /**
     * Pending transcriptions queue list.
     * Per user decision:
     * - Show visible pending list of queued items
     * - Swipe to delete queued transcriptions
     */
    export function QueueList({ items, onDelete, isReplaying }: QueueListProps) {
      if (items.length === 0) {
        return null;
      }

      return (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <h3 className="text-sm font-medium text-gray-600">
              Pendientes ({items.length})
            </h3>
            {isReplaying && (
              <span className="text-xs text-blue-500 flex items-center gap-1">
                <span className="w-3 h-3 border-2 border-blue-500 border-t-transparent rounded-full animate-spin" />
                Enviando...
              </span>
            )}
          </div>
          <div className="space-y-2">
            {items.map((item) => (
              <QueueItem
                key={item.id}
                item={item}
                onDelete={() => onDelete(item.id)}
              />
            ))}
          </div>
        </div>
      );
    }

    interface QueueItemProps {
      item: QueuedTranscription;
      onDelete: () => void;
    }

    function QueueItem({ item, onDelete }: QueueItemProps) {
      const [translateX, setTranslateX] = useState(0);
      const [isDragging, setIsDragging] = useState(false);
      const startXRef = useRef(0);
      const DELETE_THRESHOLD = -80;

      // Format timestamp
      const time = new Date(item.timestamp).toLocaleTimeString('es-AR', {
        hour: '2-digit',
        minute: '2-digit',
      });

      // Truncate text for display
      const displayText = item.text.length > 50
        ? item.text.substring(0, 50) + '...'
        : item.text;

      const handleTouchStart = (e: React.TouchEvent) => {
        startXRef.current = e.touches[0].clientX;
        setIsDragging(true);
      };

      const handleTouchMove = (e: React.TouchEvent) => {
        if (!isDragging) return;
        const currentX = e.touches[0].clientX;
        const diff = currentX - startXRef.current;
        // Only allow swipe left
        if (diff < 0) {
          setTranslateX(Math.max(diff, -100));
        }
      };

      const handleTouchEnd = () => {
        setIsDragging(false);
        if (translateX < DELETE_THRESHOLD) {
          onDelete();
        } else {
          setTranslateX(0);
        }
      };

      return (
        <div className="relative overflow-hidden rounded-lg">
          {/* Delete background */}
          <div className="absolute inset-y-0 right-0 w-20 bg-red-500 flex items-center justify-center">
            <svg
              className="w-6 h-6 text-white"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
              />
            </svg>
          </div>

          {/* Item content */}
          <div
            className="relative bg-white border border-gray-200 rounded-lg p-3 transition-transform"
            style={{
              transform: `translateX(${translateX}px)`,
              transition: isDragging ? 'none' : 'transform 0.2s ease-out',
            }}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          >
            <div className="flex justify-between items-start gap-2">
              <div className="flex-1 min-w-0">
                <p className="text-gray-700 text-sm">{displayText}</p>
                <p className="text-gray-400 text-xs mt-1">
                  Para: {item.deviceId}
                </p>
              </div>
              <span className="text-gray-400 text-xs whitespace-nowrap">
                {time}
              </span>
            </div>
          </div>
        </div>
      );
    }
    ```
  </action>
  <verify>
    File exists: `cat mobile-app/src/components/QueueList.tsx`
    Has swipe logic: grep for "handleTouchMove"
    Shows pending count: grep for "Pendientes"
  </verify>
  <done>
    QueueList shows pending transcriptions with count.
    QueueItem supports touch swipe-to-delete gesture.
    Shows target device and timestamp per item.
    Shows spinner during replay.
  </done>
</task>

</tasks>

<verification>
1. `ls mobile-app/src/hooks/useQueue.ts` exists
2. `ls mobile-app/src/components/TranscriptionEditor.tsx` exists
3. `ls mobile-app/src/components/QueueList.tsx` exists
4. `ls mobile-app/src/components/SuccessFeedback.tsx` exists
5. `cd mobile-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- useQueue manages queue state with add/remove/replay operations
- TranscriptionEditor shows live text during recording
- TranscriptionEditor provides editable text field in editing mode
- TranscriptionEditor shows errors inline
- QueueList displays pending items with swipe-to-delete
- SuccessFeedback shows brief checkmark animation
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-mobile-app-voice/03-06-SUMMARY.md`
</output>

---
phase: 04-linux-desktop-agent
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - linux-agent/src/agent/reconnect.ts
  - linux-agent/src/agent/connection.ts
  - linux-agent/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent connects to backend with hostname-based deviceId"
    - "Agent reconnects automatically with exponential backoff"
    - "Agent responds to heartbeat pings and detects connection loss"
    - "Agent receives transcriptions and calls pasteText"
    - "Agent sends ACK after processing transcription"
    - "Agent shuts down gracefully on SIGINT/SIGTERM"
  artifacts:
    - path: "linux-agent/src/agent/reconnect.ts"
      provides: "Exponential backoff manager"
      exports: ["ReconnectionManager"]
    - path: "linux-agent/src/agent/connection.ts"
      provides: "WebSocket connection handler"
      exports: ["AgentConnection"]
    - path: "linux-agent/src/index.ts"
      provides: "Entry point with graceful shutdown"
      contains: "process.on"
  key_links:
    - from: "linux-agent/src/agent/connection.ts"
      to: "linux-agent/src/paste/paste.ts"
      via: "import pasteText"
      pattern: "from '../paste/paste"
    - from: "linux-agent/src/agent/connection.ts"
      to: "ws"
      via: "WebSocket connection"
      pattern: "new WebSocket"
    - from: "linux-agent/src/index.ts"
      to: "linux-agent/src/startup.ts"
      via: "validateDependencies call"
      pattern: "validateDependencies"
---

<objective>
Implement the WebSocket connection logic with reconnection, heartbeat handling, and the entry point with dependency validation and graceful shutdown.

Purpose: Complete the Linux agent so it can connect to backend, receive transcriptions, paste them, and handle network issues identically to the Windows agent.

Output: Fully functional linux-agent that connects, receives text, pastes it, and handles reconnection/shutdown.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-linux-desktop-agent/04-CONTEXT.md
@.planning/phases/04-linux-desktop-agent/04-RESEARCH.md
@windows-agent/src/agent/reconnect.ts
@windows-agent/src/agent/connection.ts
@windows-agent/src/index.ts
@linux-agent/src/types.ts
@linux-agent/src/config.ts
@linux-agent/src/startup.ts
@linux-agent/src/paste/paste.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reconnection manager</name>
  <files>
    linux-agent/src/agent/reconnect.ts
  </files>
  <action>
Create reconnection manager identical to Windows agent (LIN-07 - shared behavior):

1. Create src/agent/reconnect.ts - exact copy from windows-agent:

```typescript
import { config } from '../config.js';

/**
 * Manages exponential backoff for reconnection
 * Delay grows: 1s -> 2s -> 4s -> 8s -> 16s -> 30s (max)
 * Adds 10-20% jitter to prevent thundering herd
 */
export class ReconnectionManager {
  private attempt = 0;

  /**
   * Calculate next reconnection delay with jitter
   * @returns Delay in milliseconds
   */
  getNextDelay(): number {
    const baseDelay = Math.min(
      config.RECONNECT_MIN_DELAY * Math.pow(config.RECONNECT_FACTOR, this.attempt),
      config.RECONNECT_MAX_DELAY
    );

    // Add jitter: config.RECONNECT_JITTER centered (e.g., 0.15 = 10-20% variance)
    const jitterRange = config.RECONNECT_JITTER * 2;
    const jitterOffset = config.RECONNECT_JITTER / 2;
    const jitter = (Math.random() * jitterRange - jitterOffset) * baseDelay;

    this.attempt++;
    return Math.round(baseDelay + jitter);
  }

  /**
   * Get current attempt number (for logging)
   */
  getAttempt(): number {
    return this.attempt;
  }

  /**
   * Reset attempt counter on successful connection
   */
  reset(): void {
    this.attempt = 0;
  }
}
```

This is identical to Windows - same reconnection timing per research recommendation.
  </action>
  <verify>
    tsc compiles without errors
    reconnect.ts exports ReconnectionManager class
  </verify>
  <done>
    ReconnectionManager exists with getNextDelay(), getAttempt(), reset() methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create connection handler</name>
  <files>
    linux-agent/src/agent/connection.ts
  </files>
  <action>
Create connection handler identical to Windows agent:

1. Create src/agent/connection.ts - same as windows-agent:

```typescript
import WebSocket from 'ws';
import os from 'os';
import pino from 'pino';
import { ReconnectionManager } from './reconnect.js';
import { pasteText } from '../paste/paste.js';
import { config } from '../config.js';
import type { ServerMessage, AgentMessage, ConnectionState } from '../types.js';

const logger = pino({ name: 'agent-connection' });

/**
 * WebSocket connection manager for the Linux desktop agent
 * Handles: registration, message processing, heartbeat, reconnection
 */
export class AgentConnection {
  private ws: WebSocket | null = null;
  private heartbeatTimeout: NodeJS.Timeout | null = null;
  private reconnectTimeout: NodeJS.Timeout | null = null;
  private reconnectManager = new ReconnectionManager();
  private state: ConnectionState = 'disconnected';
  private readonly deviceId: string;
  private readonly url: string;

  constructor(url: string = config.BACKEND_URL) {
    this.url = url;
    this.deviceId = os.hostname(); // LIN-02
    logger.info({ deviceId: this.deviceId }, 'Agent initialized');
  }

  /**
   * Start connection to backend (LIN-01)
   */
  connect(): void {
    if (this.state === 'connecting' || this.state === 'connected' || this.state === 'registered') {
      logger.warn('Already connected or connecting');
      return;
    }

    this.state = 'connecting';
    logger.info({ url: this.url, attempt: this.reconnectManager.getAttempt() }, 'Connecting to backend');

    this.ws = new WebSocket(this.url);

    // Attach all event handlers synchronously
    this.ws.on('open', () => this.onOpen());
    this.ws.on('message', (data) => this.onMessage(data));
    this.ws.on('ping', () => this.onPing());
    this.ws.on('close', (code, reason) => this.onClose(code, reason.toString()));
    this.ws.on('error', (err) => this.onError(err));
  }

  /**
   * Gracefully close connection
   */
  close(): void {
    this.clearTimers();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.state = 'disconnected';
    logger.info('Connection closed');
  }

  private onOpen(): void {
    this.state = 'connected';
    logger.info('WebSocket connected, registering...');

    // Send registration message (LIN-01, LIN-02)
    const registerMsg: AgentMessage = { type: 'register', deviceId: this.deviceId };
    this.ws!.send(JSON.stringify(registerMsg));

    this.state = 'registered';
    this.reconnectManager.reset();
    this.resetHeartbeatTimeout();

    logger.info({ deviceId: this.deviceId }, 'Registered with backend');
  }

  private async onMessage(data: WebSocket.RawData): Promise<void> {
    try {
      const msg = JSON.parse(data.toString()) as ServerMessage;

      if (msg.type === 'transcription') {
        logger.info({ id: msg.id, textLength: msg.text.length }, 'Received transcription');

        // Process: paste the text (LIN-03, LIN-04, LIN-05)
        const result = await pasteText(msg.text);

        if (result.success) {
          logger.info({ id: msg.id, method: result.method }, 'Paste succeeded');
        } else {
          logger.warn({ id: msg.id, method: result.method, error: result.error }, 'Paste failed, clipboard-only');
        }

        // Send ACK after processing
        const ack: AgentMessage = { type: 'ack', id: msg.id };
        this.ws?.send(JSON.stringify(ack));
        logger.debug({ id: msg.id }, 'ACK sent');
      }
    } catch (err) {
      logger.error({ err, data: data.toString() }, 'Failed to process message');
    }
  }

  private onPing(): void {
    // ws library automatically responds with pong
    // We just reset our heartbeat timeout
    this.resetHeartbeatTimeout();
    logger.debug('Ping received, pong sent');
  }

  private onClose(code: number, reason: string): void {
    this.clearTimers();
    this.state = 'disconnected';

    if (code === 4000) {
      // DUPLICATE_CONNECTION - another agent with same deviceId
      logger.error({ code, reason }, 'Duplicate connection - another agent already registered');
      this.scheduleReconnect(config.RECONNECT_MAX_DELAY);
    } else {
      logger.warn({ code, reason }, 'Connection closed');
      this.scheduleReconnect();
    }
  }

  private onError(err: Error): void {
    logger.error({ err }, 'WebSocket error');
    // Error is usually followed by close, so reconnection happens there
  }

  private resetHeartbeatTimeout(): void {
    if (this.heartbeatTimeout) {
      clearTimeout(this.heartbeatTimeout);
    }

    this.heartbeatTimeout = setTimeout(() => {
      // No ping received in HEARTBEAT_TIMEOUT ms - connection dead
      logger.warn('Heartbeat timeout - connection appears dead');
      this.ws?.terminate(); // Hard close, triggers onClose -> reconnect
    }, config.HEARTBEAT_TIMEOUT);
  }

  private scheduleReconnect(overrideDelay?: number): void {
    const delay = overrideDelay ?? this.reconnectManager.getNextDelay();
    logger.info({ delayMs: delay, attempt: this.reconnectManager.getAttempt() }, 'Scheduling reconnection');

    this.reconnectTimeout = setTimeout(() => {
      this.connect();
    }, delay);
  }

  private clearTimers(): void {
    if (this.heartbeatTimeout) {
      clearTimeout(this.heartbeatTimeout);
      this.heartbeatTimeout = null;
    }
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
  }

  /**
   * Get current connection state (for testing/debugging)
   */
  getState(): ConnectionState {
    return this.state;
  }
}
```

Identical to Windows agent except for log name change to 'linux' context.
  </action>
  <verify>
    tsc compiles without errors
    connection.ts exports AgentConnection class
    AgentConnection imports pasteText from paste module
  </verify>
  <done>
    AgentConnection exists with connect(), close(), state management, and message handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create entry point with startup validation</name>
  <files>
    linux-agent/src/index.ts
  </files>
  <action>
Create entry point that validates dependencies before connecting:

1. Create src/index.ts:

```typescript
import pino from 'pino';
import { AgentConnection } from './agent/connection.js';
import { validateDependencies } from './startup.js';
import { config } from './config.js';

const logger = pino({ name: 'speecher-agent' });

async function main(): Promise<void> {
  logger.info({ backendUrl: config.BACKEND_URL }, 'Starting Speecher Linux Agent');

  // Validate X11 and xdotool before proceeding (LIN-06)
  try {
    await validateDependencies();
    logger.info('Dependencies validated: DISPLAY set, xdotool available');
  } catch (err) {
    logger.error({ err }, 'Dependency validation failed');
    process.exit(1);
  }

  const agent = new AgentConnection();

  // Handle graceful shutdown
  const shutdown = (): void => {
    logger.info('Shutting down...');
    agent.close();
    process.exit(0);
  };

  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);

  // Start connection (LIN-01)
  agent.connect();

  logger.info('Agent started. Press Ctrl+C to stop.');
}

main().catch((err) => {
  logger.error({ err }, 'Fatal error');
  process.exit(1);
});
```

Key difference from Windows: calls validateDependencies() before creating AgentConnection.
  </action>
  <verify>
    tsc compiles without errors
    npm run build succeeds for entire project
    index.ts imports validateDependencies and calls it
  </verify>
  <done>
    Entry point exists with dependency validation, graceful shutdown, and agent startup
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. cd linux-agent && npm run build - should succeed
2. Verify dist/ has all compiled JS files
3. Review index.js for correct async/await structure around validateDependencies
</verification>

<success_criteria>
- linux-agent/src/agent/ has reconnect.ts and connection.ts
- linux-agent/src/index.ts exists with startup validation
- npm run build succeeds with no errors
- Agent would validate X11/xdotool before connecting to backend
- Agent handles SIGINT/SIGTERM for graceful shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/04-linux-desktop-agent/04-03-SUMMARY.md`
</output>

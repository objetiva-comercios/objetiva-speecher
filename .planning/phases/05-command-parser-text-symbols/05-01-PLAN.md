---
phase: 05-command-parser-text-symbols
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - mobile-app/src/services/commandParser.ts
  - mobile-app/src/services/commandParser.test.ts
autonomous: true

must_haves:
  truths:
    - "parseCommands('punto') returns '.'"
    - "parseCommands('hola punto adios') returns 'hola. adios'"
    - "parseCommands('contrapunto') returns 'contrapunto' (word boundary)"
    - "parseCommands('literal punto') returns 'punto' (escape syntax)"
    - "parseCommands('Punto') returns '.' (case-insensitive)"
    - "parseCommands('dos puntos') returns ':' (multi-word)"
  artifacts:
    - path: "mobile-app/src/services/commandParser.ts"
      provides: "Pure parser function with command dictionary"
      exports: ["parseCommands"]
    - path: "mobile-app/src/services/commandParser.test.ts"
      provides: "Test coverage for all command mappings"
      min_lines: 100
  key_links:
    - from: "commandParser.ts"
      to: "COMMANDS dictionary"
      via: "sorted by length for longest-match-first"
      pattern: "COMMANDS.*sort"
---

<objective>
Implement the command parser as a pure function with TDD methodology.

Purpose: Create a well-tested parser that converts Spanish voice commands to punctuation/symbols. TDD ensures all edge cases are covered (word boundaries, multi-word commands, escape syntax, case insensitivity).

Output: `commandParser.ts` with exported `parseCommands` function and comprehensive test suite.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-command-parser-text-symbols/05-CONTEXT.md
@.planning/phases/05-command-parser-text-symbols/05-RESEARCH.md
</context>

<feature>
  <name>Command Parser</name>
  <files>mobile-app/src/services/commandParser.ts, mobile-app/src/services/commandParser.test.ts</files>
  <behavior>
    Pure function: parseCommands(text: string) => string

    Command mappings (from CONTEXT.md):
    **Punctuation:**
    - "punto" -> "."
    - "coma" -> ","
    - "dos puntos" -> ":"
    - "punto y coma" -> ";"
    - "signo de interrogacion" / "interrogacion" -> "?"
    - "signo de exclamacion" / "exclamacion" -> "!"
    - "guion" -> "-"

    **Symbols:**
    - "arroba" -> "@"
    - "hashtag" / "numeral" -> "#"
    - "dolar" -> "$"
    - "porcentaje" -> "%"
    - "espacio" -> " " (explicit space)

    **Paired symbols (open/close):**
    - "abre parentesis" / "cierra parentesis" -> "(" / ")"
    - "abre corchete" / "cierra corchete" -> "[" / "]"
    - "abre llave" / "cierra llave" -> "{" / "}"
    - "abre comillas" / "cierra comillas" -> '"' / '"'
    - "abre comilla simple" / "cierra comilla simple" -> "'" / "'"

    **Compound:**
    - "punto com" -> ".com"

    **Escape mechanism:**
    - "literal X" -> "X" (preserves following word as-is)

    **Edge cases:**
    - Case-insensitive: "Punto", "PUNTO", "punto" all -> "."
    - Word boundaries: "contrapunto" stays unchanged
    - Multi-word adjacency: "abre parentesis" works, "abre un parentesis" doesn't
    - Space normalization: "hola punto adios" -> "hola. adios" (no space before punctuation)

    Test cases (input -> expected output):
    - "punto" -> "."
    - "coma" -> ","
    - "hola punto adios" -> "hola. adios"
    - "hola coma adios" -> "hola, adios"
    - "contrapunto" -> "contrapunto"
    - "Punto" -> "."
    - "PUNTO" -> "."
    - "dos puntos" -> ":"
    - "punto y coma" -> ";"
    - "abre parentesis hola cierra parentesis" -> "(hola)"
    - "arroba ejemplo punto com" -> "@ejemplo.com"
    - "literal punto" -> "punto"
    - "literal coma mas coma" -> "coma mas,"
    - "espacio espacio" -> "  " (two explicit spaces)
    - "hola espacio espacio adios" -> "hola  adios"
    - "" -> ""
    - "normal text" -> "normal text"
  </behavior>
  <implementation>
    1. Define CommandDef interface: { patterns: string[], output: string }
    2. Create COMMANDS array sorted by pattern length descending (longest first)
    3. Implement parseCommands function:
       a. Handle empty input
       b. Handle escape sequences ("literal X") first using placeholder replacement
       c. Process commands in order (longest patterns first to avoid partial matches)
       d. Use regex with \b word boundaries and 'gi' flags
       e. Normalize spaces: remove space before punctuation that attaches, collapse multiple spaces (except explicit espacio)
       f. Restore escaped words from placeholders
    4. Export parseCommands function

    Key implementation details from RESEARCH.md:
    - Use \b for word boundaries (works for Spanish Latin script)
    - Escape special regex chars in command patterns
    - Sort commands by length descending to match "punto y coma" before "punto"
    - Use placeholder (\u0000ESC{n}\u0000) for escape sequences during processing
  </implementation>
</feature>

<verification>
```bash
cd mobile-app && npm test -- --run commandParser
```
All tests pass, covering:
- All command mappings
- Case insensitivity
- Word boundary protection
- Multi-word command matching
- Escape syntax
- Space normalization
</verification>

<success_criteria>
- parseCommands function exported from commandParser.ts
- All 20+ command mappings implemented per CONTEXT.md
- Test file covers all commands, edge cases, and the escape mechanism
- Tests pass with `npm test -- --run commandParser`
</success_criteria>

<output>
After completion, create `.planning/phases/05-command-parser-text-symbols/05-01-SUMMARY.md`
</output>

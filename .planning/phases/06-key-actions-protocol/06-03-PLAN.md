---
phase: 06-key-actions-protocol
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend-server/src/routes/transcription.ts
  - backend-server/src/services/queue.ts
  - backend-server/src/websocket/handler.ts
autonomous: true

must_haves:
  truths:
    - "Backend accepts POST /transcription with payload field containing Segment[]"
    - "Backend forwards payload to agents via WebSocket unchanged"
    - "Queue stores and delivers messages with payload field"
  artifacts:
    - path: "backend-server/src/routes/transcription.ts"
      provides: "Updated route accepting payload format"
      contains: "payload"
    - path: "backend-server/src/services/queue.ts"
      provides: "Queue supporting Segment[] storage"
      contains: "payload"
  key_links:
    - from: "backend-server/src/routes/transcription.ts"
      to: "backend-server/src/websocket/handler.ts"
      via: "ServerMessage with payload forwarded to agents"
      pattern: "payload.*Segment"
---

<objective>
Update backend to accept and forward Segment-based payload messages.

Purpose: Implements BACK-09 (accept messages with key actions) and BACK-10 (forward key actions to agents). Backend becomes a pass-through for the payload field, which agents will process.

Output: Updated transcription route, queue service, and WebSocket handler supporting payload field.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-key-actions-protocol/06-RESEARCH.md
@.planning/phases/06-key-actions-protocol/06-01-SUMMARY.md

# Source files
@backend-server/src/routes/transcription.ts
@backend-server/src/services/queue.ts
@backend-server/src/websocket/handler.ts
@backend-server/src/types/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update transcription route to accept payload</name>
  <files>backend-server/src/routes/transcription.ts</files>
  <action>
Update the POST /transcription route to accept payload format:

1. Update TranscriptionBody interface:
```typescript
import type { Segment } from '../types/messages.js';

interface TranscriptionBody {
  deviceId: string;
  payload: Segment[];  // New: array of segments
  text?: string;       // Deprecated: for backwards compatibility
}
```

2. Update Fastify schema to accept payload:
```typescript
schema: {
  body: {
    type: 'object',
    required: ['deviceId', 'payload'],
    properties: {
      deviceId: { type: 'string', minLength: 1 },
      payload: {
        type: 'array',
        items: {
          type: 'object',
          oneOf: [
            {
              properties: {
                type: { const: 'text' },
                value: { type: 'string' }
              },
              required: ['type', 'value']
            },
            {
              properties: {
                type: { const: 'key' },
                key: { enum: ['enter', 'tab'] }
              },
              required: ['type', 'key']
            }
          ]
        }
      }
    },
  },
},
```

3. Update routeTranscription function:
- Change parameter from `text: string` to `payload: Segment[]`
- Update ServerMessage creation to include payload instead of text
- Keep text field empty/undefined for new messages

4. Update queueMessage function:
- Change parameter from `text: string` to `payload: Segment[]`
- Store payload in the queued message

Note: The backwards compatibility with `text` field is handled by the updated types from Plan 01. Old agents will see `text: undefined` but new agents will use `payload`.
  </action>
  <verify>
```bash
cd backend-server && npx tsc --noEmit
cd backend-server && npm test
```
  </verify>
  <done>
- TranscriptionBody has payload field
- Route schema validates payload as Segment[]
- ServerMessage sent to agents includes payload field
- Queue stores payload correctly
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update queue service for payload storage</name>
  <files>backend-server/src/services/queue.ts</files>
  <action>
Update the queue service to store and deliver payload:

1. Import Segment type:
```typescript
import type { Segment, QueuedMessage } from '../types/messages.js';
```

2. The QueuedMessage type was already updated in Plan 01 to include `payload?: Segment[]`. Verify the enqueue function accepts messages with payload.

3. Update any queue retrieval functions to preserve the payload field when building ServerMessage for delivery.

4. If there's a function that converts QueuedMessage to ServerMessage, ensure it passes through the payload field:
```typescript
const serverMessage: ServerMessage = {
  type: 'transcription',
  id: msg.id,
  payload: msg.payload,  // Pass through segments
  timestamp: msg.timestamp,
};
```

The queue is mostly a pass-through storage - the main change is ensuring payload is stored and retrieved correctly.
  </action>
  <verify>
```bash
cd backend-server && npx tsc --noEmit
```
  </verify>
  <done>
- Queue enqueue accepts messages with payload field
- Queue dequeue/flush returns messages with payload preserved
- Payload converted to ServerMessage correctly on delivery
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify WebSocket handler forwards payload</name>
  <files>backend-server/src/websocket/handler.ts</files>
  <action>
Verify the WebSocket handler correctly forwards messages with payload:

1. Check the handler that sends queued messages to agents on reconnect
2. Ensure ServerMessage serialization includes payload field
3. The handler should already work since ServerMessage type was updated

If needed, update any message construction to include payload:
```typescript
// When sending to agent
const message: ServerMessage = {
  type: 'transcription',
  id: msg.id,
  payload: msg.payload,  // Include payload
  timestamp: msg.timestamp,
};
ws.send(JSON.stringify(message));
```

Most likely no changes needed if the ServerMessage type is used correctly and JSON.stringify is called on the full object.

Also check the ack.ts file if it constructs ServerMessage objects.
  </action>
  <verify>
```bash
cd backend-server && npx tsc --noEmit
cd backend-server && npm run build
```
  </verify>
  <done>
- WebSocket handler sends messages with payload to agents
- Queued message delivery includes payload
- Build succeeds
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Manual curl test:
```bash
curl -X POST http://localhost:3000/transcription \
  -H "Content-Type: application/json" \
  -d '{"deviceId":"test","payload":[{"type":"text","value":"hello"},{"type":"key","key":"enter"}]}'
```
Should return success response (may fail with AGENT_OFFLINE if no agent, but validates schema).
</verification>

<success_criteria>
- POST /transcription accepts { deviceId, payload: Segment[] }
- Fastify schema validates Segment array structure
- Messages with payload are queued and delivered correctly
- WebSocket messages to agents include payload field
- TypeScript compiles, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-key-actions-protocol/06-03-SUMMARY.md`
</output>

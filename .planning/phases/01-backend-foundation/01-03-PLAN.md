---
phase: 01-backend-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - backend-server/src/websocket/handler.ts
  - backend-server/src/websocket/heartbeat.ts
  - backend-server/src/websocket/ack.ts
autonomous: true

must_haves:
  truths:
    - "Agent can connect via WebSocket with deviceId"
    - "Duplicate connections are rejected with close"
    - "Agent is removed from registry on disconnect"
    - "Heartbeat pings every 30 seconds"
    - "Agent is terminated after 2 missed pongs"
    - "ACK waiting mechanism with timeout exists"
  artifacts:
    - path: "backend-server/src/websocket/handler.ts"
      provides: "WebSocket connection handler with registration"
      exports: ["createWebSocketHandler"]
    - path: "backend-server/src/websocket/heartbeat.ts"
      provides: "Ping/pong heartbeat management"
      exports: ["startHeartbeat", "stopHeartbeat"]
    - path: "backend-server/src/websocket/ack.ts"
      provides: "ACK waiting for message delivery confirmation"
      exports: ["sendAndWaitForAck", "handleAck", "clearPendingAcks"]
  key_links:
    - from: "backend-server/src/websocket/handler.ts"
      to: "backend-server/src/services/registry.ts"
      via: "registerAgent/unregisterAgent calls"
      pattern: "import.*from.*registry"
    - from: "backend-server/src/websocket/handler.ts"
      to: "backend-server/src/websocket/ack.ts"
      via: "handleAck for incoming messages"
      pattern: "import.*handleAck"
---

<objective>
Implement WebSocket connection handling with registration, heartbeat, and ACK mechanism.

Purpose: The WebSocket layer enables real-time communication with desktop agents. Registration tracks which agents are online, heartbeat detects dead connections, and ACK confirms message delivery for reliable routing.
Output: Complete WebSocket infrastructure ready to be wired into Fastify.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
@backend-server/src/types/messages.ts
@backend-server/src/services/registry.ts
@backend-server/src/services/queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ACK waiting mechanism</name>
  <files>backend-server/src/websocket/ack.ts</files>
  <action>
Create the ACK mechanism for confirming message delivery before responding to HTTP POST.

Per user decision: Wait for ACK from desktop agent before responding to POST /transcription.

Create `backend-server/src/websocket/ack.ts`:

```typescript
import type { WebSocket } from 'ws';
import type { ServerMessage } from '../types/messages.js';

// Default timeout: 5 seconds (per research recommendation, local network)
const DEFAULT_ACK_TIMEOUT_MS = 5000;

interface PendingAck {
  resolve: (success: boolean) => void;
  timeout: NodeJS.Timeout;
  deviceId: string;
}

// Map: message id -> pending ack info
const pendingAcks = new Map<string, PendingAck>();

/**
 * Send a message to agent and wait for ACK.
 * Returns true if ACK received, false if timeout.
 */
export async function sendAndWaitForAck(
  socket: WebSocket,
  message: ServerMessage,
  deviceId: string,
  timeoutMs: number = DEFAULT_ACK_TIMEOUT_MS
): Promise<boolean> {
  if (message.type !== 'transcription') {
    // Only transcription messages need ACK
    socket.send(JSON.stringify(message));
    return true;
  }

  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      pendingAcks.delete(message.id);
      resolve(false);
    }, timeoutMs);

    pendingAcks.set(message.id, { resolve, timeout, deviceId });
    socket.send(JSON.stringify(message));
  });
}

/**
 * Handle incoming ACK message from agent.
 * Called from WebSocket message handler.
 */
export function handleAck(messageId: string): boolean {
  const pending = pendingAcks.get(messageId);
  if (!pending) {
    return false; // No pending ACK for this message
  }

  clearTimeout(pending.timeout);
  pending.resolve(true);
  pendingAcks.delete(messageId);
  return true;
}

/**
 * Clear all pending ACKs for a device (called on disconnect).
 * Prevents memory leaks from timeouts.
 */
export function clearPendingAcks(deviceId: string): void {
  for (const [messageId, pending] of pendingAcks.entries()) {
    if (pending.deviceId === deviceId) {
      clearTimeout(pending.timeout);
      pending.resolve(false); // Resolve as failed
      pendingAcks.delete(messageId);
    }
  }
}

/**
 * Check if there are pending ACKs for a device.
 */
export function hasPendingAcks(deviceId: string): boolean {
  for (const pending of pendingAcks.values()) {
    if (pending.deviceId === deviceId) {
      return true;
    }
  }
  return false;
}
```

Key points:
- 5 second timeout per research recommendation
- Clears timeouts on disconnect to prevent memory leaks (per pitfall #2)
- Only transcription messages need ACK
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>ACK mechanism with timeout, cleanup on disconnect</done>
</task>

<task type="auto">
  <name>Task 2: Implement heartbeat management</name>
  <files>backend-server/src/websocket/heartbeat.ts</files>
  <action>
Create heartbeat using protocol-level ping/pong from ws library.

Per user decision:
- Ping every 30 seconds
- Disconnect after 2 missed pongs

Create `backend-server/src/websocket/heartbeat.ts`:

```typescript
import { getAllAgents, unregisterAgent, setAgentAlive } from '../services/registry.js';
import { clearPendingAcks } from './ack.js';
import type { FastifyBaseLogger } from 'fastify';

const HEARTBEAT_INTERVAL_MS = 30000; // 30 seconds per user decision

let heartbeatInterval: NodeJS.Timeout | null = null;

/**
 * Start the heartbeat interval.
 * Pings all connected agents and terminates those that missed pongs.
 *
 * Per user decision: disconnect after 2 missed pongs.
 * Implementation: First miss sets isAlive=false, second miss terminates.
 */
export function startHeartbeat(logger: FastifyBaseLogger): void {
  if (heartbeatInterval) {
    return; // Already running
  }

  heartbeatInterval = setInterval(() => {
    const agents = getAllAgents();

    agents.forEach((agent, deviceId) => {
      if (!agent.isAlive) {
        // Missed previous pong - terminate connection
        logger.info({ deviceId }, 'Agent missed heartbeat pong, terminating');
        agent.socket.terminate();
        unregisterAgent(deviceId);
        clearPendingAcks(deviceId);
        return;
      }

      // Mark as not alive until pong received
      setAgentAlive(deviceId, false);

      // Send ping (protocol-level)
      agent.socket.ping();
    });
  }, HEARTBEAT_INTERVAL_MS);

  logger.info('Heartbeat started (30s interval)');
}

/**
 * Stop the heartbeat interval.
 * Called on server shutdown.
 */
export function stopHeartbeat(): void {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
  }
}
```

Key points:
- Uses ws library's protocol-level ping (not application-level)
- Two-strike policy: first miss marks !isAlive, second terminates
- Clears pending ACKs on termination (memory leak prevention)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>Heartbeat with 30s interval, 2-missed-pong termination</done>
</task>

<task type="auto">
  <name>Task 3: Implement WebSocket connection handler</name>
  <files>backend-server/src/websocket/handler.ts</files>
  <action>
Create the WebSocket handler that manages agent connections.

Per user decisions:
- Register agent with hostname as deviceId
- Reject duplicate connections
- Remove immediately on disconnect

Per research pitfall #1: Attach event handlers synchronously.

Create `backend-server/src/websocket/handler.ts`:

```typescript
import type { WebSocket } from 'ws';
import type { FastifyRequest, FastifyBaseLogger } from 'fastify';
import type { AgentMessage } from '../types/messages.js';
import {
  registerAgent,
  unregisterAgent,
  getAgent,
  setAgentAlive,
  normalizeDeviceId,
} from '../services/registry.js';
import { drainQueue, hasQueuedMessages } from '../services/queue.js';
import { handleAck, clearPendingAcks, sendAndWaitForAck } from './ack.js';

/**
 * Create the WebSocket connection handler for Fastify.
 *
 * IMPORTANT: Per research pitfall #1, attach all event handlers synchronously
 * before any async operations to avoid dropping messages.
 */
export function createWebSocketHandler(logger: FastifyBaseLogger) {
  return function handleConnection(socket: WebSocket, request: FastifyRequest): void {
    let deviceId: string | null = null;

    // Attach all handlers SYNCHRONOUSLY (per research pitfall #1)

    socket.on('message', (data) => {
      try {
        const message: AgentMessage = JSON.parse(data.toString());

        if (message.type === 'register') {
          handleRegister(socket, message.deviceId, logger);
          deviceId = normalizeDeviceId(message.deviceId);
        } else if (message.type === 'ack') {
          handleAck(message.id);
          logger.debug({ messageId: message.id, deviceId }, 'ACK received');
        }
      } catch (error) {
        logger.error({ error, deviceId }, 'Failed to parse WebSocket message');
      }
    });

    socket.on('pong', () => {
      // Heartbeat response - mark as alive
      if (deviceId) {
        setAgentAlive(deviceId, true);
        logger.debug({ deviceId }, 'Pong received');
      }
    });

    socket.on('close', () => {
      if (deviceId) {
        logger.info({ deviceId }, 'Agent disconnected');
        unregisterAgent(deviceId);
        clearPendingAcks(deviceId);
      }
    });

    socket.on('error', (error) => {
      logger.error({ error, deviceId }, 'WebSocket error');
      // Don't unregister here - 'close' event will handle it
    });

    logger.debug({ ip: request.ip }, 'WebSocket connection opened, awaiting registration');
  };
}

/**
 * Handle agent registration message.
 */
function handleRegister(
  socket: WebSocket,
  rawDeviceId: string,
  logger: FastifyBaseLogger
): void {
  const deviceId = normalizeDeviceId(rawDeviceId);

  // Check for duplicate connection (per user decision: reject new)
  const existing = getAgent(deviceId);
  if (existing) {
    logger.warn({ deviceId }, 'Duplicate connection rejected');
    socket.close(4000, 'DUPLICATE_CONNECTION');
    return;
  }

  // Register the agent
  const registered = registerAgent(deviceId, socket);
  if (!registered) {
    // Shouldn't happen after the check above, but handle gracefully
    socket.close(4000, 'REGISTRATION_FAILED');
    return;
  }

  logger.info({ deviceId }, 'Agent registered');

  // Deliver any queued messages (per user decision: immediate burst)
  if (hasQueuedMessages(deviceId)) {
    deliverQueuedMessages(socket, deviceId, logger);
  }
}

/**
 * Deliver queued messages to newly connected agent.
 * Per user decision: immediate burst delivery.
 */
async function deliverQueuedMessages(
  socket: WebSocket,
  deviceId: string,
  logger: FastifyBaseLogger
): Promise<void> {
  const messages = drainQueue(deviceId);

  if (messages.length === 0) {
    return;
  }

  logger.info({ deviceId, count: messages.length }, 'Delivering queued messages');

  // Send all messages immediately (burst delivery per user decision)
  for (const msg of messages) {
    const serverMessage = {
      type: 'transcription' as const,
      id: msg.id,
      text: msg.text,
      timestamp: msg.timestamp,
    };

    // Note: We don't wait for ACK on queued messages - they're already accepted
    // The mobile app already got 200 OK when they were queued
    socket.send(JSON.stringify(serverMessage));
  }

  logger.info({ deviceId, count: messages.length }, 'Queued messages delivered');
}
```

Key implementation notes:
- All event handlers attached synchronously (pitfall #1)
- Uses close code 4000 for duplicate rejection (WebSocket custom codes)
- Queued messages delivered immediately on registration (burst)
- Clears pending ACKs on disconnect (memory leak prevention)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>WebSocket handler with registration, duplicate rejection, disconnect cleanup, queue delivery</done>
</task>

</tasks>

<verification>
1. All WebSocket files exist in backend-server/src/websocket/
2. `npx tsc --noEmit` compiles without errors
3. Handler attaches event listeners synchronously
4. Heartbeat uses protocol-level ping
5. ACK mechanism has proper timeout cleanup
</verification>

<success_criteria>
- handler.ts: createWebSocketHandler function with sync event attachment
- heartbeat.ts: startHeartbeat, stopHeartbeat with 30s interval
- ack.ts: sendAndWaitForAck, handleAck, clearPendingAcks with 5s timeout
- All compile without TypeScript errors
- Memory leak prevention via timeout cleanup on disconnect
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-03-SUMMARY.md`
</output>

---
phase: 01-backend-foundation
plan: 05
type: execute
wave: 4
depends_on: ["01-03", "01-04"]
files_modified:
  - backend-server/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Server starts and listens on configured port"
    - "WebSocket connections accepted at /ws endpoint"
    - "HTTP routes registered and responding"
    - "Heartbeat starts on server boot"
    - "Structured JSON logging is active"
    - "Graceful shutdown cleans up resources"
  artifacts:
    - path: "backend-server/src/index.ts"
      provides: "Fastify server entry point"
      min_lines: 50
  key_links:
    - from: "backend-server/src/index.ts"
      to: "backend-server/src/routes/transcription.ts"
      via: "fastify.register(transcriptionRoute)"
      pattern: "register.*transcriptionRoute"
    - from: "backend-server/src/index.ts"
      to: "backend-server/src/routes/devices.ts"
      via: "fastify.register(devicesRoute)"
      pattern: "register.*devicesRoute"
    - from: "backend-server/src/index.ts"
      to: "backend-server/src/websocket/handler.ts"
      via: "WebSocket route with handler"
      pattern: "createWebSocketHandler"
    - from: "backend-server/src/index.ts"
      to: "backend-server/src/websocket/heartbeat.ts"
      via: "startHeartbeat on ready"
      pattern: "startHeartbeat"
---

<objective>
Wire up Fastify server with all routes, WebSocket, and heartbeat.

Purpose: This is the integration plan that brings all components together into a running server. Creates the entry point that starts everything.
Output: Complete, runnable backend server with all Phase 1 functionality.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
@backend-server/src/types/messages.ts
@backend-server/src/services/registry.ts
@backend-server/src/services/queue.ts
@backend-server/src/websocket/handler.ts
@backend-server/src/websocket/heartbeat.ts
@backend-server/src/routes/transcription.ts
@backend-server/src/routes/devices.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Fastify server entry point</name>
  <files>backend-server/src/index.ts</files>
  <action>
Create the main entry point that wires everything together.

Per user decision: Structured JSON logs (Pino via Fastify).
Per research: Use @fastify/websocket for WebSocket support.

Create `backend-server/src/index.ts`:

```typescript
import Fastify from 'fastify';
import websocket from '@fastify/websocket';
import { transcriptionRoute } from './routes/transcription.js';
import { devicesRoute } from './routes/devices.js';
import { createWebSocketHandler } from './websocket/handler.js';
import { startHeartbeat, stopHeartbeat } from './websocket/heartbeat.js';

// Configuration (can be overridden via environment)
const PORT = parseInt(process.env.PORT || '3000', 10);
const HOST = process.env.HOST || '0.0.0.0';

// Create Fastify instance with structured JSON logging
const fastify = Fastify({
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    // Pino outputs structured JSON by default
  },
});

// Register WebSocket plugin
await fastify.register(websocket, {
  options: {
    maxPayload: 1048576, // 1MB max message size
  },
});

// Register HTTP routes
await fastify.register(transcriptionRoute);
await fastify.register(devicesRoute);

// Register WebSocket route
fastify.get('/ws', { websocket: true }, createWebSocketHandler(fastify.log));

// Health check endpoint (optional, useful for monitoring)
fastify.get('/health', async () => {
  return { status: 'ok', timestamp: new Date().toISOString() };
});

// Start heartbeat when server is ready
fastify.addHook('onReady', async () => {
  startHeartbeat(fastify.log);
  fastify.log.info('Server ready, heartbeat started');
});

// Graceful shutdown
const shutdown = async (signal: string) => {
  fastify.log.info({ signal }, 'Received shutdown signal');
  stopHeartbeat();
  await fastify.close();
  process.exit(0);
};

process.on('SIGTERM', () => shutdown('SIGTERM'));
process.on('SIGINT', () => shutdown('SIGINT'));

// Start the server
try {
  await fastify.listen({ port: PORT, host: HOST });
  fastify.log.info({ port: PORT, host: HOST }, 'Server listening');
} catch (err) {
  fastify.log.error(err);
  process.exit(1);
}
```

Key implementation notes:
- Uses top-level await (ESM with Node.js 20+)
- Binds to 0.0.0.0 for local network access
- Graceful shutdown stops heartbeat and closes server
- Health endpoint for basic monitoring
- Structured JSON logging via Pino (Fastify default)
  </action>
  <verify>
1. Run `npx tsc` to compile TypeScript to dist/
2. Run `npm run dev` to start in development mode
3. Verify server starts: `curl http://localhost:3000/health`
4. Verify devices endpoint: `curl http://localhost:3000/devices`
5. Check logs are structured JSON
  </verify>
  <done>Server starts, accepts connections, routes work, heartbeat running</done>
</task>

<task type="auto">
  <name>Task 2: Add npm scripts and verify full flow</name>
  <files>backend-server/package.json</files>
  <action>
Update package.json with proper scripts and verify the complete flow works.

Add/update scripts in package.json:

```json
{
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "typecheck": "tsc --noEmit"
  }
}
```

Then verify the complete flow:

1. Build: `npm run build`
2. Start dev server: `npm run dev`
3. Test health: `curl http://localhost:3000/health`
4. Test devices (empty): `curl http://localhost:3000/devices`
5. Test transcription to offline device:
   ```bash
   curl -X POST http://localhost:3000/transcription \
     -H "Content-Type: application/json" \
     -d '{"deviceId": "test-device", "text": "Hello world"}'
   ```
   Should return `{"success":true,"messageId":"...","queued":true}`

6. Verify logs are structured JSON format
  </action>
  <verify>
1. `npm run build` succeeds with no errors
2. `npm run dev` starts server
3. All curl commands return expected responses
4. Logs show structured JSON with timestamps
  </verify>
  <done>All npm scripts work, server runs, endpoints respond correctly</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm run dev` starts server on port 3000
3. GET /health returns { status: 'ok' }
4. GET /devices returns { success: true, devices: [] }
5. POST /transcription queues message for offline device
6. Logs are structured JSON with proper fields
7. SIGINT gracefully shuts down server
</verification>

<success_criteria>
- Server starts and listens on port 3000
- All routes respond correctly
- WebSocket endpoint available at /ws
- Heartbeat starts automatically
- Graceful shutdown works
- Structured JSON logging active
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-05-SUMMARY.md`
</output>

---
phase: 01-backend-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - backend-server/src/routes/transcription.ts
  - backend-server/src/routes/devices.ts
autonomous: true

must_haves:
  truths:
    - "POST /transcription accepts deviceId and text"
    - "POST returns 200 for successful delivery or queuing"
    - "POST returns 200 with queued flag when agent offline"
    - "POST returns 500 only for server errors"
    - "GET /devices returns list of connected agent hostnames"
  artifacts:
    - path: "backend-server/src/routes/transcription.ts"
      provides: "POST /transcription route with routing logic"
      exports: ["transcriptionRoute"]
    - path: "backend-server/src/routes/devices.ts"
      provides: "GET /devices route for device listing"
      exports: ["devicesRoute"]
  key_links:
    - from: "backend-server/src/routes/transcription.ts"
      to: "backend-server/src/services/registry.ts"
      via: "getAgent for connection lookup"
      pattern: "import.*getAgent.*from"
    - from: "backend-server/src/routes/transcription.ts"
      to: "backend-server/src/services/queue.ts"
      via: "enqueue for offline messages"
      pattern: "import.*enqueue.*from"
    - from: "backend-server/src/routes/transcription.ts"
      to: "backend-server/src/websocket/ack.ts"
      via: "sendAndWaitForAck for delivery confirmation"
      pattern: "import.*sendAndWaitForAck.*from"
---

<objective>
Implement HTTP routes for transcription submission and device listing.

Purpose: These routes are the API that mobile apps use to send transcriptions and discover available desktop agents. POST /transcription is the main entry point for the voice-to-cursor flow.
Output: Two route plugins ready to be registered with Fastify.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
@backend-server/src/types/messages.ts
@backend-server/src/services/registry.ts
@backend-server/src/services/queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement POST /transcription route</name>
  <files>backend-server/src/routes/transcription.ts</files>
  <action>
Create the transcription route that routes messages to desktop agents.

Per user decisions in CONTEXT.md:
- JSON only for requests/responses
- HTTP 200 for successful accepts (including queued)
- HTTP 500 for server errors only
- Wait for ACK before responding
- Queue if agent offline
- Detailed error codes in response body

Create `backend-server/src/routes/transcription.ts`:

```typescript
import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { getAgent } from '../services/registry.js';
import { enqueue } from '../services/queue.js';
import { sendAndWaitForAck } from '../websocket/ack.js';
import type { ApiResponse, ServerMessage } from '../types/messages.js';

interface TranscriptionBody {
  deviceId: string;
  text: string;
}

/**
 * POST /transcription route plugin.
 *
 * Routes transcription text to the specified desktop agent.
 * Per user decision: 200 for all accepts, 500 for server errors only.
 */
export async function transcriptionRoute(fastify: FastifyInstance): Promise<void> {
  fastify.post<{ Body: TranscriptionBody }>(
    '/transcription',
    {
      schema: {
        body: {
          type: 'object',
          required: ['deviceId', 'text'],
          properties: {
            deviceId: { type: 'string', minLength: 1 },
            text: { type: 'string' },
          },
        },
      },
    },
    async (request: FastifyRequest<{ Body: TranscriptionBody }>, reply: FastifyReply) => {
      const { deviceId, text } = request.body;

      // Validate deviceId (redundant with Fastify schema, but explicit for clarity)
      // Note: Fastify schema already validates minLength:1, so this is a safety net
      if (!deviceId || typeof deviceId !== 'string' || deviceId.trim() === '') {
        // Per user decision: 200 for all responses, error details in body for client handling
        // INVALID_DEVICE_ID is a client validation error, NOT a server error
        const response: ApiResponse = {
          success: false,
          error: {
            code: 'INVALID_DEVICE_ID',
            message: 'deviceId is required and must be a non-empty string',
          },
        };
        return reply.code(200).send(response);
      }

      try {
        const result = await routeTranscription(deviceId, text, request.log);
        return reply.code(200).send(result);
      } catch (error) {
        request.log.error({ error, deviceId }, 'Transcription routing failed');
        const response: ApiResponse = {
          success: false,
          error: {
            code: 'INTERNAL_ERROR',
            message: 'Failed to process transcription',
          },
        };
        return reply.code(500).send(response);
      }
    }
  );
}

/**
 * Route transcription to agent or queue if offline.
 */
async function routeTranscription(
  deviceId: string,
  text: string,
  logger: FastifyInstance['log']
): Promise<ApiResponse> {
  const messageId = crypto.randomUUID();
  const timestamp = Date.now();

  const agent = getAgent(deviceId);

  if (!agent) {
    // Agent offline - queue the message
    logger.info({ deviceId, messageId }, 'Agent offline, queuing message');
    return queueMessage(deviceId, messageId, text, timestamp);
  }

  // Agent online - send and wait for ACK
  const serverMessage: ServerMessage = {
    type: 'transcription',
    id: messageId,
    text,
    timestamp,
  };

  const ackReceived = await sendAndWaitForAck(agent.socket, serverMessage, deviceId);

  if (ackReceived) {
    logger.info({ deviceId, messageId }, 'Transcription delivered and acknowledged');
    return {
      success: true,
      messageId,
      queued: false,
    };
  } else {
    // ACK timeout - queue for retry
    // Per research: ACK_TIMEOUT means agent might be unresponsive
    logger.warn({ deviceId, messageId }, 'ACK timeout, queuing for retry');
    return queueMessage(deviceId, messageId, text, timestamp);
  }
}

/**
 * Queue a message for offline/unresponsive agent.
 */
function queueMessage(
  deviceId: string,
  messageId: string,
  text: string,
  timestamp: number
): ApiResponse {
  const result = enqueue(deviceId, { id: messageId, text, timestamp });

  if (result.success) {
    return {
      success: true,
      messageId,
      queued: true,
    };
  } else {
    // Queue full
    return {
      success: false,
      error: {
        code: 'QUEUE_FULL',
        message: 'Message queue is full for this device (max 50 messages)',
      },
    };
  }
}
```

Key implementation notes:
- Uses crypto.randomUUID() for message IDs (built-in, no deps)
- Schema validation via Fastify's built-in JSON schema
- Returns 200 for ALL responses (success or client error), error details in body
- 500 ONLY for unexpected server errors (caught exceptions)
- Client errors (INVALID_DEVICE_ID, QUEUE_FULL) return 200 with success:false
- Queues on ACK timeout (agent might be slow or dead)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>POST /transcription with routing, queuing, ACK waiting, proper status codes</done>
</task>

<task type="auto">
  <name>Task 2: Implement GET /devices route</name>
  <files>backend-server/src/routes/devices.ts</files>
  <action>
Create the devices listing route for mobile app device discovery.

Per user decisions:
- Returns list of connected agent hostnames
- JSON response

Create `backend-server/src/routes/devices.ts`:

```typescript
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { getConnectedDevices } from '../services/registry.js';

interface DevicesResponse {
  success: boolean;
  devices: string[];
}

/**
 * GET /devices route plugin.
 *
 * Returns list of currently connected desktop agent hostnames.
 * Mobile app uses this to populate device selection list.
 */
export async function devicesRoute(fastify: FastifyInstance): Promise<void> {
  fastify.get('/devices', async (_request: FastifyRequest, reply: FastifyReply) => {
    try {
      const devices = getConnectedDevices();

      const response: DevicesResponse = {
        success: true,
        devices,
      };

      return reply.code(200).send(response);
    } catch (error) {
      fastify.log.error({ error }, 'Failed to get connected devices');
      return reply.code(500).send({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to get connected devices',
        },
      });
    }
  });
}
```

Simple route - just reads from registry and returns device list.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>GET /devices returns connected device hostnames</done>
</task>

</tasks>

<verification>
1. Both route files exist in backend-server/src/routes/
2. `npx tsc --noEmit` compiles without errors
3. POST /transcription has schema validation
4. Routes use proper error codes from types
</verification>

<success_criteria>
- transcription.ts: transcriptionRoute plugin with POST handling
- devices.ts: devicesRoute plugin with GET handling
- Both use correct HTTP status codes (200/500)
- Both use ApiResponse types
- Both compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-04-SUMMARY.md`
</output>

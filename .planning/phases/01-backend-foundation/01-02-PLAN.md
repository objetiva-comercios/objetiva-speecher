---
phase: 01-backend-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend-server/src/services/registry.ts
  - backend-server/src/services/queue.ts
autonomous: true

must_haves:
  truths:
    - "Registry can track agent connections by deviceId"
    - "Registry rejects duplicate connections"
    - "Registry returns list of connected device names"
    - "Queue stores messages for offline agents"
    - "Queue enforces 50 message limit per device"
    - "Queue prunes messages older than 24 hours"
  artifacts:
    - path: "backend-server/src/services/registry.ts"
      provides: "Connection registry with Map-based storage"
      exports: ["registerAgent", "unregisterAgent", "getAgent", "getConnectedDevices", "normalizeDeviceId"]
    - path: "backend-server/src/services/queue.ts"
      provides: "Message queue with size and TTL limits"
      exports: ["enqueue", "drainQueue", "getQueueSize"]
  key_links:
    - from: "backend-server/src/services/registry.ts"
      to: "backend-server/src/types/messages.ts"
      via: "imports AgentConnection type"
      pattern: "import.*AgentConnection.*from"
    - from: "backend-server/src/services/queue.ts"
      to: "backend-server/src/types/messages.ts"
      via: "imports QueuedMessage type"
      pattern: "import.*QueuedMessage.*from"
---

<objective>
Implement the connection registry and message queue services.

Purpose: These services manage agent connections and offline message storage. The registry tracks which desktop agents are connected, while the queue holds transcriptions for agents that are temporarily offline. Both are core to the routing logic.
Output: Two service modules with full CRUD operations for connections and queued messages.
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-CONTEXT.md
@.planning/phases/01-backend-foundation/01-RESEARCH.md
@backend-server/src/types/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement connection registry service</name>
  <files>backend-server/src/services/registry.ts</files>
  <action>
Create the connection registry using a Map for efficient add/delete operations.

Implement per user decisions in CONTEXT.md:
- Hostname as deviceId (case-insensitive per research recommendation)
- Reject duplicate connections
- Remove immediately on disconnect

Create `backend-server/src/services/registry.ts`:

```typescript
import type { WebSocket } from 'ws';
import type { AgentConnection } from '../types/messages.js';

// Map: normalized deviceId -> connection
const registry = new Map<string, AgentConnection>();

/**
 * Normalize deviceId for case-insensitive matching.
 * Windows hostnames may differ in case from Linux.
 */
export function normalizeDeviceId(raw: string): string {
  return raw.toLowerCase().trim();
}

/**
 * Register a new agent connection.
 * Returns false if duplicate (per user decision: reject new connection).
 */
export function registerAgent(deviceId: string, socket: WebSocket): boolean {
  const normalized = normalizeDeviceId(deviceId);

  if (registry.has(normalized)) {
    return false; // Reject duplicate per user decision
  }

  registry.set(normalized, {
    socket,
    deviceId: normalized,
    connectedAt: new Date(),
    isAlive: true,
  });

  return true;
}

/**
 * Remove agent from registry (called on disconnect).
 * Per user decision: remove immediately.
 */
export function unregisterAgent(deviceId: string): void {
  const normalized = normalizeDeviceId(deviceId);
  registry.delete(normalized);
}

/**
 * Get agent connection by deviceId.
 */
export function getAgent(deviceId: string): AgentConnection | undefined {
  const normalized = normalizeDeviceId(deviceId);
  return registry.get(normalized);
}

/**
 * Get list of all connected device IDs.
 * Used by GET /devices endpoint.
 */
export function getConnectedDevices(): string[] {
  return Array.from(registry.keys());
}

/**
 * Update isAlive status for heartbeat tracking.
 */
export function setAgentAlive(deviceId: string, isAlive: boolean): void {
  const normalized = normalizeDeviceId(deviceId);
  const agent = registry.get(normalized);
  if (agent) {
    agent.isAlive = isAlive;
  }
}

/**
 * Get all agents for heartbeat iteration.
 */
export function getAllAgents(): Map<string, AgentConnection> {
  return registry;
}
```

Key implementation notes:
- Uses Map for O(1) lookup and efficient iteration
- Case-insensitive deviceId matching per research
- Returns boolean on register to signal duplicate rejection
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>Registry service exports all functions, handles duplicates, case-insensitive matching works</done>
</task>

<task type="auto">
  <name>Task 2: Implement message queue service</name>
  <files>backend-server/src/services/queue.ts</files>
  <action>
Create the message queue for storing transcriptions when agents are offline.

Implement per user decisions in CONTEXT.md:
- Max 50 messages per device
- 24-hour TTL (older messages dropped)
- Strict ordering (FIFO)

Create `backend-server/src/services/queue.ts`:

```typescript
import type { QueuedMessage } from '../types/messages.js';
import { normalizeDeviceId } from './registry.js';

const MAX_QUEUE_SIZE = 50;
const MAX_QUEUE_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours

// Map: normalized deviceId -> array of queued messages
const messageQueues = new Map<string, QueuedMessage[]>();

/**
 * Add message to queue for offline agent.
 * Returns success status and error code if queue is full.
 */
export function enqueue(
  deviceId: string,
  message: QueuedMessage
): { success: true } | { success: false; code: 'QUEUE_FULL' } {
  const normalized = normalizeDeviceId(deviceId);
  let queue = messageQueues.get(normalized) || [];

  // Prune expired messages first
  const now = Date.now();
  queue = queue.filter(m => now - m.timestamp < MAX_QUEUE_AGE_MS);

  // Check queue size limit
  if (queue.length >= MAX_QUEUE_SIZE) {
    return { success: false, code: 'QUEUE_FULL' };
  }

  // Add message (maintains strict ordering per user decision)
  queue.push(message);
  messageQueues.set(normalized, queue);

  return { success: true };
}

/**
 * Get and remove all queued messages for a device.
 * Called when agent reconnects for "immediate burst" delivery.
 * Returns messages in strict order (FIFO).
 */
export function drainQueue(deviceId: string): QueuedMessage[] {
  const normalized = normalizeDeviceId(deviceId);
  const queue = messageQueues.get(normalized) || [];

  // Clear the queue
  messageQueues.delete(normalized);

  // Filter expired before returning (in case not pruned recently)
  const now = Date.now();
  return queue.filter(m => now - m.timestamp < MAX_QUEUE_AGE_MS);
}

/**
 * Get current queue size for a device (for debugging/monitoring).
 */
export function getQueueSize(deviceId: string): number {
  const normalized = normalizeDeviceId(deviceId);
  const queue = messageQueues.get(normalized) || [];
  return queue.length;
}

/**
 * Check if device has queued messages.
 */
export function hasQueuedMessages(deviceId: string): boolean {
  const normalized = normalizeDeviceId(deviceId);
  const queue = messageQueues.get(normalized);
  return queue !== undefined && queue.length > 0;
}
```

Key implementation notes:
- Prunes expired messages on each enqueue (lazy cleanup)
- Returns queue in FIFO order for strict ordering
- Uses same normalizeDeviceId for consistency with registry
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile correctly.
  </verify>
  <done>Queue service enforces 50 message limit, 24h TTL, strict ordering</done>
</task>

</tasks>

<verification>
1. Both service files exist in backend-server/src/services/
2. `npx tsc --noEmit` compiles without errors
3. Registry handles duplicate rejection correctly
4. Queue enforces size and TTL limits
</verification>

<success_criteria>
- registry.ts exports: registerAgent, unregisterAgent, getAgent, getConnectedDevices, normalizeDeviceId, setAgentAlive, getAllAgents
- queue.ts exports: enqueue, drainQueue, getQueueSize, hasQueuedMessages
- Both use consistent deviceId normalization (case-insensitive)
- Both compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-02-SUMMARY.md`
</output>

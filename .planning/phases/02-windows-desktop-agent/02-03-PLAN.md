---
phase: 02-windows-desktop-agent
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - windows-agent/src/agent/reconnect.ts
  - windows-agent/src/agent/connection.ts
  - windows-agent/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent connects to backend with hostname as deviceId"
    - "Agent reconnects with exponential backoff after disconnection"
    - "Agent responds to heartbeat pings (automatic via ws library)"
    - "Agent sends ACK after processing transcription"
    - "Agent logs paste events for debugging"
  artifacts:
    - path: "windows-agent/src/agent/reconnect.ts"
      provides: "Exponential backoff with jitter"
      contains: "getNextDelay"
    - path: "windows-agent/src/agent/connection.ts"
      provides: "WebSocket connection manager"
      contains: "AgentConnection"
    - path: "windows-agent/src/index.ts"
      provides: "Entry point that starts agent"
      contains: "main"
  key_links:
    - from: "windows-agent/src/agent/connection.ts"
      to: "windows-agent/src/agent/reconnect.ts"
      via: "uses ReconnectionManager"
      pattern: "import.*reconnect"
    - from: "windows-agent/src/agent/connection.ts"
      to: "windows-agent/src/paste/paste.ts"
      via: "calls pasteText on transcription"
      pattern: "import.*paste"
    - from: "windows-agent/src/index.ts"
      to: "windows-agent/src/agent/connection.ts"
      via: "creates and starts connection"
      pattern: "import.*connection"
---

<objective>
Implement WebSocket connection management with exponential backoff reconnection and the agent entry point.

Purpose: Enable the agent to connect to backend, receive transcriptions, and maintain connection through network interruptions.
Output: Fully functional agent that connects, receives text, pastes it, and reconnects on failure
</objective>

<execution_context>
@C:\Users\luish\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luish\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-windows-desktop-agent/02-RESEARCH.md
@windows-agent/src/types.ts
@windows-agent/src/config.ts
@windows-agent/src/paste/paste.ts
@backend-server/src/types/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement exponential backoff reconnection manager</name>
  <files>windows-agent/src/agent/reconnect.ts</files>
  <action>
Create windows-agent/src/agent/reconnect.ts with exponential backoff logic:

```typescript
import { config } from '../config.js';

/**
 * Manages exponential backoff for reconnection (RES-04)
 * Delay grows: 1s -> 2s -> 4s -> 8s -> 16s -> 30s (max)
 * Adds 10-20% jitter to prevent thundering herd
 */
export class ReconnectionManager {
  private attempt = 0;

  /**
   * Calculate next reconnection delay with jitter
   * @returns Delay in milliseconds
   */
  getNextDelay(): number {
    const baseDelay = Math.min(
      config.RECONNECT_MIN_DELAY * Math.pow(config.RECONNECT_FACTOR, this.attempt),
      config.RECONNECT_MAX_DELAY
    );

    // Add jitter: config.RECONNECT_JITTER centered (e.g., 0.15 = 10-20% variance)
    const jitterRange = config.RECONNECT_JITTER * 2; // e.g., 0.3
    const jitterOffset = config.RECONNECT_JITTER / 2; // e.g., 0.075
    const jitter = (Math.random() * jitterRange - jitterOffset) * baseDelay;

    this.attempt++;
    return Math.round(baseDelay + jitter);
  }

  /**
   * Get current attempt number (for logging)
   */
  getAttempt(): number {
    return this.attempt;
  }

  /**
   * Reset attempt counter on successful connection
   */
  reset(): void {
    this.attempt = 0;
  }
}
```

The jitter calculation ensures 10-20% variance around the base delay.
  </action>
  <verify>npx tsc --noEmit passes, reconnect.ts exports ReconnectionManager</verify>
  <done>ReconnectionManager provides exponential backoff (1s-30s) with jitter, resets on success</done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket connection handler</name>
  <files>windows-agent/src/agent/connection.ts</files>
  <action>
Create windows-agent/src/agent/connection.ts with full connection management:

```typescript
import WebSocket from 'ws';
import os from 'os';
import pino from 'pino';
import { ReconnectionManager } from './reconnect.js';
import { pasteText } from '../paste/paste.js';
import { config } from '../config.js';
import type { ServerMessage, AgentMessage, ConnectionState } from '../types.js';

const logger = pino({ name: 'agent-connection' });

/**
 * WebSocket connection manager for the desktop agent
 * Handles: registration, message processing, heartbeat, reconnection
 */
export class AgentConnection {
  private ws: WebSocket | null = null;
  private heartbeatTimeout: NodeJS.Timeout | null = null;
  private reconnectTimeout: NodeJS.Timeout | null = null;
  private reconnectManager = new ReconnectionManager();
  private state: ConnectionState = 'disconnected';
  private readonly deviceId: string;
  private readonly url: string;

  constructor(url: string = config.BACKEND_URL) {
    this.url = url;
    this.deviceId = os.hostname(); // WIN-02
    logger.info({ deviceId: this.deviceId }, 'Agent initialized');
  }

  /**
   * Start connection to backend
   */
  connect(): void {
    if (this.state === 'connecting' || this.state === 'connected' || this.state === 'registered') {
      logger.warn('Already connected or connecting');
      return;
    }

    this.state = 'connecting';
    logger.info({ url: this.url, attempt: this.reconnectManager.getAttempt() }, 'Connecting to backend');

    this.ws = new WebSocket(this.url);

    // Attach all event handlers synchronously (research pitfall #1)
    this.ws.on('open', () => this.onOpen());
    this.ws.on('message', (data) => this.onMessage(data));
    this.ws.on('ping', () => this.onPing());
    this.ws.on('close', (code, reason) => this.onClose(code, reason.toString()));
    this.ws.on('error', (err) => this.onError(err));
  }

  /**
   * Gracefully close connection
   */
  close(): void {
    this.clearTimers();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.state = 'disconnected';
    logger.info('Connection closed');
  }

  private onOpen(): void {
    this.state = 'connected';
    logger.info('WebSocket connected, registering...');

    // Send registration message (WIN-01, WIN-02)
    const registerMsg: AgentMessage = { type: 'register', deviceId: this.deviceId };
    this.ws!.send(JSON.stringify(registerMsg));

    this.state = 'registered';
    this.reconnectManager.reset();
    this.resetHeartbeatTimeout();

    logger.info({ deviceId: this.deviceId }, 'Registered with backend');
  }

  private async onMessage(data: WebSocket.RawData): Promise<void> {
    try {
      const msg = JSON.parse(data.toString()) as ServerMessage;

      if (msg.type === 'transcription') {
        logger.info({ id: msg.id, textLength: msg.text.length }, 'Received transcription');

        // Process: paste the text (WIN-03 through WIN-08, DEL-02)
        const result = await pasteText(msg.text);

        // DEL-05: Log paste event
        if (result.success) {
          logger.info({ id: msg.id, method: result.method }, 'Paste succeeded');
        } else {
          logger.warn({ id: msg.id, method: result.method, error: result.error }, 'Paste failed, clipboard-only');
        }

        // Send ACK after processing
        const ack: AgentMessage = { type: 'ack', id: msg.id };
        this.ws?.send(JSON.stringify(ack));
        logger.debug({ id: msg.id }, 'ACK sent');
      }
    } catch (err) {
      logger.error({ err, data: data.toString() }, 'Failed to process message');
    }
  }

  private onPing(): void {
    // ws library automatically responds with pong (RES-05)
    // We just reset our heartbeat timeout (RES-06)
    this.resetHeartbeatTimeout();
    logger.debug('Ping received, pong sent');
  }

  private onClose(code: number, reason: string): void {
    this.clearTimers();
    this.state = 'disconnected';

    if (code === 4000) {
      // DUPLICATE_CONNECTION - another agent with same deviceId
      logger.error({ code, reason }, 'Duplicate connection - another agent already registered');
      // Don't reconnect immediately - wait longer
      this.scheduleReconnect(config.RECONNECT_MAX_DELAY);
    } else {
      logger.warn({ code, reason }, 'Connection closed');
      this.scheduleReconnect();
    }
  }

  private onError(err: Error): void {
    logger.error({ err }, 'WebSocket error');
    // Error is usually followed by close, so reconnection happens there
  }

  private resetHeartbeatTimeout(): void {
    if (this.heartbeatTimeout) {
      clearTimeout(this.heartbeatTimeout);
    }

    this.heartbeatTimeout = setTimeout(() => {
      // No ping received in HEARTBEAT_TIMEOUT ms - connection dead (RES-06)
      logger.warn('Heartbeat timeout - connection appears dead');
      this.ws?.terminate(); // Hard close, triggers onClose -> reconnect
    }, config.HEARTBEAT_TIMEOUT);
  }

  private scheduleReconnect(overrideDelay?: number): void {
    const delay = overrideDelay ?? this.reconnectManager.getNextDelay();
    logger.info({ delayMs: delay, attempt: this.reconnectManager.getAttempt() }, 'Scheduling reconnection');

    this.reconnectTimeout = setTimeout(() => {
      this.connect();
    }, delay);
  }

  private clearTimers(): void {
    if (this.heartbeatTimeout) {
      clearTimeout(this.heartbeatTimeout);
      this.heartbeatTimeout = null;
    }
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
  }

  /**
   * Get current connection state (for testing/debugging)
   */
  getState(): ConnectionState {
    return this.state;
  }
}
```

This implements all connection requirements:
- WIN-01: WebSocket connection
- WIN-02: Hostname-based deviceId
- WIN-03: Receives transcription messages
- RES-04: Exponential backoff (via ReconnectionManager)
- RES-05: Responds to pings (automatic via ws library)
- RES-06: Detects missed pongs via heartbeat timeout
- DEL-05: Logs paste events
  </action>
  <verify>npx tsc --noEmit passes, connection.ts exports AgentConnection class</verify>
  <done>AgentConnection handles connect/register/message/heartbeat/reconnect with logging</done>
</task>

<task type="auto">
  <name>Task 3: Create agent entry point</name>
  <files>windows-agent/src/index.ts</files>
  <action>
Create windows-agent/src/index.ts as the entry point:

```typescript
import pino from 'pino';
import { AgentConnection } from './agent/connection.js';
import { config } from './config.js';

const logger = pino({ name: 'speecher-agent' });

async function main(): Promise<void> {
  logger.info({ backendUrl: config.BACKEND_URL }, 'Starting Speecher Windows Agent');

  const agent = new AgentConnection();

  // Handle graceful shutdown
  const shutdown = (): void => {
    logger.info('Shutting down...');
    agent.close();
    process.exit(0);
  };

  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);

  // Start connection
  agent.connect();

  logger.info('Agent started. Press Ctrl+C to stop.');
}

main().catch((err) => {
  logger.error({ err }, 'Fatal error');
  process.exit(1);
});
```

Test the agent compiles and runs:
1. `npx tsc` - should compile to dist/
2. `npm run dev` - should start and attempt connection (will fail if backend not running, that's OK)

Note: For dev testing, backend must be running. Agent will log connection attempts and reconnection delays.
  </action>
  <verify>npx tsc compiles without errors, npm run dev starts agent and logs connection attempt</verify>
  <done>Entry point starts agent, connects to backend, handles SIGINT/SIGTERM gracefully</done>
</task>

</tasks>

<verification>
1. `cd windows-agent && npx tsc` builds to dist/ without errors
2. `npm run dev` starts and logs "Starting Speecher Windows Agent"
3. If backend not running: logs reconnection attempts with exponential backoff delays
4. If backend running: agent registers, appears in /devices, receives transcriptions
5. Agent handles Ctrl+C gracefully
</verification>

<success_criteria>
- Agent connects to backend with os.hostname() as deviceId (WIN-01, WIN-02)
- Reconnection uses exponential backoff 1s-30s with jitter (RES-04)
- Heartbeat timeout of 35s detects dead connections (RES-06)
- Transcription messages trigger paste flow and send ACK
- Paste events logged with success/failure and method (DEL-05)
- Duplicate connection (code 4000) handled with delayed reconnect
- TypeScript compiles to dist/
</success_criteria>

<output>
After completion, create `.planning/phases/02-windows-desktop-agent/02-03-SUMMARY.md`
</output>
